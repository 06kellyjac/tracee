{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tracee: Runtime Security and Forensics using eBPF Tracee is a Runtime Security and forensics tool for Linux. It is using Linux eBPF technology to trace your system and applications at runtime, and analyze collected events to detect suspicious behavioral patterns. It is delivered as a Docker image that monitors the OS and detects suspicious behavior based on a predefined set of behavioral patterns. Watch a quick video demo of Tracee: Check out the Tracee video hub for more. Quickstart Before you proceed, make sure you follow the minimum requirements for running Tracee . docker run --name tracee --rm --privileged -it aquasec/tracee:latest Note: __Running bpf requires access to the kernel configuration file. Depending on the linux distribution this can be in either /proc/config.gz (which docker mounts by default) or /boot/config-$(uname -r) (which must be mounted explicitly)._ This will run Tracee with the portable CO:RE bpf object and default settings. It will start reporting detections to standard output. In order to simulate a suspicious behavior, you can run strace ls in another terminal, which will trigger the \"Anti-Debugging\" signature, which is loaded by default. Note: You may need to change the volume mounts for the kernel headers based on your setup if the kernel doesn't have BTF enabled. See Linux Headers section for more info. Trace In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case you can run Tracee with the trace sub-command, which will start dumping raw data directly into standard output. There are many configurations and options available so you can control exactly what is being collected and how. see the Documentation or add the --help flag for more. Components Tracee is composed of the following sub-projects, which are hosted in the aquasecurity/tracee repository: - Tracee-eBPF - Linux Tracing and Forensics using eBPF - Tracee-Rules - Runtime Security Detection Engine","title":"Getting Started"},{"location":"#tracee-runtime-security-and-forensics-using-ebpf","text":"Tracee is a Runtime Security and forensics tool for Linux. It is using Linux eBPF technology to trace your system and applications at runtime, and analyze collected events to detect suspicious behavioral patterns. It is delivered as a Docker image that monitors the OS and detects suspicious behavior based on a predefined set of behavioral patterns. Watch a quick video demo of Tracee: Check out the Tracee video hub for more.","title":"Tracee: Runtime Security and Forensics using eBPF"},{"location":"#quickstart","text":"Before you proceed, make sure you follow the minimum requirements for running Tracee . docker run --name tracee --rm --privileged -it aquasec/tracee:latest Note: __Running bpf requires access to the kernel configuration file. Depending on the linux distribution this can be in either /proc/config.gz (which docker mounts by default) or /boot/config-$(uname -r) (which must be mounted explicitly)._ This will run Tracee with the portable CO:RE bpf object and default settings. It will start reporting detections to standard output. In order to simulate a suspicious behavior, you can run strace ls in another terminal, which will trigger the \"Anti-Debugging\" signature, which is loaded by default. Note: You may need to change the volume mounts for the kernel headers based on your setup if the kernel doesn't have BTF enabled. See Linux Headers section for more info.","title":"Quickstart"},{"location":"#trace","text":"In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case you can run Tracee with the trace sub-command, which will start dumping raw data directly into standard output. There are many configurations and options available so you can control exactly what is being collected and how. see the Documentation or add the --help flag for more.","title":"Trace"},{"location":"#components","text":"Tracee is composed of the following sub-projects, which are hosted in the aquasecurity/tracee repository: - Tracee-eBPF - Linux Tracing and Forensics using eBPF - Tracee-Rules - Runtime Security Detection Engine","title":"Components"},{"location":"architecture/","text":"Architecture High level overview","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#high-level-overview","text":"","title":"High level overview"},{"location":"config/","text":"Configuration Options By default, rules are discovered from the rules directory next to the tracee-rules executable binary (you can specify a different location with the --rules-dir flag). By default, all discovered rules will be loaded unless specific rules are selected using the --rules flag.","title":"Configuration Options"},{"location":"config/#configuration-options","text":"By default, rules are discovered from the rules directory next to the tracee-rules executable binary (you can specify a different location with the --rules-dir flag). By default, all discovered rules will be loaded unless specific rules are selected using the --rules flag.","title":"Configuration Options"},{"location":"faq/","text":"FAQ - Frequently Asked Questions Secure tracing When Tracee-eBPF reads information from user programs it is subject to a race condition where the user program might be able to change the arguments after Tracee has read them. For example, a program invoked execve(\"/bin/ls\", NULL, 0) , Tracee picked that up and will report that, then the program changed the first argument from /bin/ls to /bin/bash , and this is what the kernel will execute. To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the bprm_check event which can be reported by Tracee and cross-referenced with the reported regular syscall event.","title":"FAQ"},{"location":"faq/#faq-frequently-asked-questions","text":"","title":"FAQ - Frequently Asked Questions"},{"location":"faq/#secure-tracing","text":"When Tracee-eBPF reads information from user programs it is subject to a race condition where the user program might be able to change the arguments after Tracee has read them. For example, a program invoked execve(\"/bin/ls\", NULL, 0) , Tracee picked that up and will report that, then the program changed the first argument from /bin/ls to /bin/bash , and this is what the kernel will execute. To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the bprm_check event which can be reported by Tracee and cross-referenced with the reported regular syscall event.","title":"Secure tracing"},{"location":"integrations/","text":"Integrations When a detection is made by any of the signatures, it will always be printed to stdout. You can customize the output format using a go template : tracee-rules --output-template /path/to/my.tmpl In addition, Tracee can notify a web service when a detection is made using a custom webhook: tracee-rules --webhook http://my.webhook/endpoint --webhook-template /path/to/my.tmpl --webhook-content-type application/json Included Go templates The following go templates are included in the Tracee container image and are available for use under the /tracee/templates/ directory in the container: File name Description Content-Type Source falcosidekick.tmpl For compatibility with falcosidekick application/json source rawjson.tmpl Dumps the Finding object as raw JSON application/json source Go Template Authoring When authoring a Go template for either stdout or webhook, you have Tracee's types.Finding struct as the data source: //Finding is the main output of a signature. It represents a match result for the signature business logic type Finding struct { SigMetadata SignatureMetadata //information about the signature that made the detection Context Event //the raw event that triggered the detection Data map [ string ] interface {} //detection specific information } The Go template can utilize helper functions from Sprig . For example templates, see tracee/tracee-rules/templates . Examples Raw JSON stdout The following example configures Tracee to output detections to stdout as raw JSON: docker run --rm --privileged --pid = host -v /lib/modules/:/lib/modules/:ro -v /usr/src:/usr/src:ro -v /tmp/tracee:/tmp/tracee -it aquasec/tracee --output-template /tracee/templates/rawjson.tmpl falcosidekick webhook falcosidekick is a useful webhook server that can be configured to connect to various \"outputs\" such as: Slack, Mattermost, Teams, Datadog, Prometheus, StatsD, Email, Elasticsearch, Loki, PagerDuty, OpsGenie, and many more. To use Tracee with falcosidekick: Obtain connection credentials to the system you want to integrate with. Consult the system's documentation and look for how to configure an incoming webhook. Start the falcosidekick container, configured with the obtained output credentials: See the the falcosidekick Readme for full documentation. Start Tracee while configuring it to post detections to the falcosidekick endpoint. If using Docker, you can use the simple link flag to allow the containers to communicate Use the webhook flag to point to the falcosidekick container's endpoint Tracee ships with a built-in template for falcosidekick # Start falcosidekick configured to post to Slack docker run --name falcosidekick -p 2801 :2801 -e SLACK_WEBHOOKURL = https://hooks.slack.com/services/XXX/YYY/ZZZ falcosecurity/falcosidekick # Start Tracee, linking it to the falcosidekick container, and configuring it to call it on detections docker run --rm --privileged --pid = host -v /lib/modules/:/lib/modules/:ro -v /usr/src:/usr/src:ro -v /tmp/tracee:/tmp/tracee -it --link falcosidekick aquasec/tracee --webhook-template /tracee/templates/falcosidekick.tmpl --webhook-content-type application/json --webhook http://FALCOSIDEKICK:2801","title":"Integrations"},{"location":"integrations/#integrations","text":"When a detection is made by any of the signatures, it will always be printed to stdout. You can customize the output format using a go template : tracee-rules --output-template /path/to/my.tmpl In addition, Tracee can notify a web service when a detection is made using a custom webhook: tracee-rules --webhook http://my.webhook/endpoint --webhook-template /path/to/my.tmpl --webhook-content-type application/json","title":"Integrations"},{"location":"integrations/#included-go-templates","text":"The following go templates are included in the Tracee container image and are available for use under the /tracee/templates/ directory in the container: File name Description Content-Type Source falcosidekick.tmpl For compatibility with falcosidekick application/json source rawjson.tmpl Dumps the Finding object as raw JSON application/json source","title":"Included Go templates"},{"location":"integrations/#go-template-authoring","text":"When authoring a Go template for either stdout or webhook, you have Tracee's types.Finding struct as the data source: //Finding is the main output of a signature. It represents a match result for the signature business logic type Finding struct { SigMetadata SignatureMetadata //information about the signature that made the detection Context Event //the raw event that triggered the detection Data map [ string ] interface {} //detection specific information } The Go template can utilize helper functions from Sprig . For example templates, see tracee/tracee-rules/templates .","title":"Go Template Authoring"},{"location":"integrations/#examples","text":"","title":"Examples"},{"location":"integrations/#raw-json-stdout","text":"The following example configures Tracee to output detections to stdout as raw JSON: docker run --rm --privileged --pid = host -v /lib/modules/:/lib/modules/:ro -v /usr/src:/usr/src:ro -v /tmp/tracee:/tmp/tracee -it aquasec/tracee --output-template /tracee/templates/rawjson.tmpl","title":"Raw JSON stdout"},{"location":"integrations/#falcosidekick-webhook","text":"falcosidekick is a useful webhook server that can be configured to connect to various \"outputs\" such as: Slack, Mattermost, Teams, Datadog, Prometheus, StatsD, Email, Elasticsearch, Loki, PagerDuty, OpsGenie, and many more. To use Tracee with falcosidekick: Obtain connection credentials to the system you want to integrate with. Consult the system's documentation and look for how to configure an incoming webhook. Start the falcosidekick container, configured with the obtained output credentials: See the the falcosidekick Readme for full documentation. Start Tracee while configuring it to post detections to the falcosidekick endpoint. If using Docker, you can use the simple link flag to allow the containers to communicate Use the webhook flag to point to the falcosidekick container's endpoint Tracee ships with a built-in template for falcosidekick # Start falcosidekick configured to post to Slack docker run --name falcosidekick -p 2801 :2801 -e SLACK_WEBHOOKURL = https://hooks.slack.com/services/XXX/YYY/ZZZ falcosecurity/falcosidekick # Start Tracee, linking it to the falcosidekick container, and configuring it to call it on detections docker run --rm --privileged --pid = host -v /lib/modules/:/lib/modules/:ro -v /usr/src:/usr/src:ro -v /tmp/tracee:/tmp/tracee -it --link falcosidekick aquasec/tracee --webhook-template /tracee/templates/falcosidekick.tmpl --webhook-content-type application/json --webhook http://FALCOSIDEKICK:2801","title":"falcosidekick webhook"},{"location":"rules-authoring/","text":"Authoring Rules Tracee supports authoring rules in Golang) or in Rego (the language of Open Policy Agent ). Rego rules Create a .rego file in the rules directory that has the following Rego Rules (in this context rules are Rego's language constructs): __rego_metadoc__ : A document rule that defines the rule's metadata. tracee_selected_events : A set rule that defines the event selectors. tracee_match : A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\". See tracee/tracee-rules/signatures/rego/examples for example Rego signatures. Golang Rules Tracee exports a Signature interface that you can implement. We use Go Plugins to load Go signatures. Create a new Go project with a package main Import github.com/aquasecurity/tracee/tracee-rules/types and implement the types.Signature interface. Export a package level variable called ExportedSignatures of type []types.Signature that declares the implemented signature (or more) that your package exports. Compile using goplugins go build -buildmode=plugin -o yourplugin.so yoursource.go . Place the resulting compiled file in the rules directory and it will be automatically discovered by Tracee. See tracee/tracee-rules/signatures/golang/examples for example Go signatures.","title":"Authoring Rules"},{"location":"rules-authoring/#authoring-rules","text":"Tracee supports authoring rules in Golang) or in Rego (the language of Open Policy Agent ).","title":"Authoring Rules"},{"location":"rules-authoring/#rego-rules","text":"Create a .rego file in the rules directory that has the following Rego Rules (in this context rules are Rego's language constructs): __rego_metadoc__ : A document rule that defines the rule's metadata. tracee_selected_events : A set rule that defines the event selectors. tracee_match : A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\". See tracee/tracee-rules/signatures/rego/examples for example Rego signatures.","title":"Rego rules"},{"location":"rules-authoring/#golang-rules","text":"Tracee exports a Signature interface that you can implement. We use Go Plugins to load Go signatures. Create a new Go project with a package main Import github.com/aquasecurity/tracee/tracee-rules/types and implement the types.Signature interface. Export a package level variable called ExportedSignatures of type []types.Signature that declares the implemented signature (or more) that your package exports. Compile using goplugins go build -buildmode=plugin -o yourplugin.so yoursource.go . Place the resulting compiled file in the rules directory and it will be automatically discovered by Tracee. See tracee/tracee-rules/signatures/golang/examples for example Go signatures.","title":"Golang Rules"},{"location":"rules-index/","text":"Available Rules To view the list of available rules, run Tracee with the --list flag. We are currently working on creating a library of behavioral signature detections. Currently, the following are available: Name Description Tags Standard Input/Output Over Socket Redirection of process's standard input/output to socket \"linux\", \"container\" Anti-Debugging Process uses anti-debugging technique to block debugger \"linux\", \"container\" Code injection Possible code injection into another process \"linux\", \"container\" Dynamic Code Loading Writing to executable allocated memory region \"linux\", \"container\" Fileless Execution Executing a process from memory, without a file in the disk \"linux\", \"container\" kernel module loading Attempt to load a kernel module detection \"linux\", \"container\" LD_PRELOAD Usage of LD_PRELOAD to allow hooks on process \"linux\", \"container\"","title":"Available Rules"},{"location":"rules-index/#available-rules","text":"To view the list of available rules, run Tracee with the --list flag. We are currently working on creating a library of behavioral signature detections. Currently, the following are available: Name Description Tags Standard Input/Output Over Socket Redirection of process's standard input/output to socket \"linux\", \"container\" Anti-Debugging Process uses anti-debugging technique to block debugger \"linux\", \"container\" Code injection Possible code injection into another process \"linux\", \"container\" Dynamic Code Loading Writing to executable allocated memory region \"linux\", \"container\" Fileless Execution Executing a process from memory, without a file in the disk \"linux\", \"container\" kernel module loading Attempt to load a kernel module detection \"linux\", \"container\" LD_PRELOAD Usage of LD_PRELOAD to allow hooks on process \"linux\", \"container\"","title":"Available Rules"},{"location":"install/ebpf-compilation/","text":"eBPF Compilation Tracee is leveraging Linux's eBPF technology, which requires kernel level integration. Tracee supports two eBPF integration modes: a portable mode which will seamlessly run everywhere on supporting environment, as demonstrated by the quickstart, or a kernel-specific mode that requires Tracee's eBPF program to be specifically compiled for your host. The portable option, also known as CO:RE (compile once, run everywhere), requires that your operating system support BTF (BPF Type Format). Tracee will automatically run in CO:RE mode if it detects that the environment supports it. This mode requires no intervention or preparation on your side. You can manually detect if your environments supports it by checking if the following file exists on your machine: /sys/kernel/btf/vmlinux or consult the following documentation: https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere. If you want to run Tracee on a host without BTF support you can have Tracee build the bpf object for you at runtime. This will depend on having clang and a kernel version specific kernel-header package. Alternatively, you can pre-compile the eBPF program, and provide it to Tracee. There are some benefits to this approach as you will not need to depend on clang and kernel headers, as well as reduced risk of invoking an external program at runtime. Compilation Preqrequisites Portable (CO:RE) option: - Linux kernel version >= 4.18 - libc, and the libraries: libelf, zlib - GNU Make >= 4.3 - clang >= 11 Kernel version specific option: - Linux kernel version >= 4.18 - Linux kernel headers available under conventional location (see Linux Headers section for more info) - libc, and the libraries: libelf, zlib - GNU Make >= 4.3 - clang >= 11 You can build the eBPF program in the following ways: Clone the repo (including submodules: git clone --recursive https://github.com/aquasecurity/tracee.git ) and make bpf . make bpf DOCKER=1 to build in a Docker container which includes all development tooling. Running this will produce a file called tracee.bpf.$kernelversion.$traceeversion.o under the dist directory. Once you have the eBPF program artifact, you can provide it to Tracee in any of the following locations: Path specified in TRACEE_BPF_FILE environment variable /tmp/tracee In this case, the full Docker image can be replaced by the lighter-weight aquasec/tracee:slim image. This image cannot build the eBPF program on its own, and is meant to be used when you have already compiled the eBPF program beforehand. If using Docker, the following docker run options demonstrate mounting a pre-compiled eBPF artifact into the container, and pointing Tracee to use it: docker run ... -v /path/in/host/tracee.bpf.123.o:/path/in/container/tracee.bpf.o -e TRACEE_BPF_FILE = /path/in/container/tracee.bpf.o aquasec/tracee If using Docker on a host without BTF enabled, the following docker run options demonstrate mounting of required kernel headers for building the bpf object at runtime: docker run --name tracee --rm --privileged -v /lib/modules/:/lib/modules/:ro -v /usr/src:/usr/src:ro -v /tmp/tracee:/tmp/tracee -it aquasec/tracee:latest","title":"eBPF Compilation"},{"location":"install/ebpf-compilation/#ebpf-compilation","text":"Tracee is leveraging Linux's eBPF technology, which requires kernel level integration. Tracee supports two eBPF integration modes: a portable mode which will seamlessly run everywhere on supporting environment, as demonstrated by the quickstart, or a kernel-specific mode that requires Tracee's eBPF program to be specifically compiled for your host. The portable option, also known as CO:RE (compile once, run everywhere), requires that your operating system support BTF (BPF Type Format). Tracee will automatically run in CO:RE mode if it detects that the environment supports it. This mode requires no intervention or preparation on your side. You can manually detect if your environments supports it by checking if the following file exists on your machine: /sys/kernel/btf/vmlinux or consult the following documentation: https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere. If you want to run Tracee on a host without BTF support you can have Tracee build the bpf object for you at runtime. This will depend on having clang and a kernel version specific kernel-header package. Alternatively, you can pre-compile the eBPF program, and provide it to Tracee. There are some benefits to this approach as you will not need to depend on clang and kernel headers, as well as reduced risk of invoking an external program at runtime.","title":"eBPF Compilation"},{"location":"install/ebpf-compilation/#compilation-preqrequisites","text":"Portable (CO:RE) option: - Linux kernel version >= 4.18 - libc, and the libraries: libelf, zlib - GNU Make >= 4.3 - clang >= 11 Kernel version specific option: - Linux kernel version >= 4.18 - Linux kernel headers available under conventional location (see Linux Headers section for more info) - libc, and the libraries: libelf, zlib - GNU Make >= 4.3 - clang >= 11 You can build the eBPF program in the following ways: Clone the repo (including submodules: git clone --recursive https://github.com/aquasecurity/tracee.git ) and make bpf . make bpf DOCKER=1 to build in a Docker container which includes all development tooling. Running this will produce a file called tracee.bpf.$kernelversion.$traceeversion.o under the dist directory. Once you have the eBPF program artifact, you can provide it to Tracee in any of the following locations: Path specified in TRACEE_BPF_FILE environment variable /tmp/tracee In this case, the full Docker image can be replaced by the lighter-weight aquasec/tracee:slim image. This image cannot build the eBPF program on its own, and is meant to be used when you have already compiled the eBPF program beforehand. If using Docker, the following docker run options demonstrate mounting a pre-compiled eBPF artifact into the container, and pointing Tracee to use it: docker run ... -v /path/in/host/tracee.bpf.123.o:/path/in/container/tracee.bpf.o -e TRACEE_BPF_FILE = /path/in/container/tracee.bpf.o aquasec/tracee If using Docker on a host without BTF enabled, the following docker run options demonstrate mounting of required kernel headers for building the bpf object at runtime: docker run --name tracee --rm --privileged -v /lib/modules/:/lib/modules/:ro -v /usr/src:/usr/src:ro -v /tmp/tracee:/tmp/tracee -it aquasec/tracee:latest","title":"Compilation Preqrequisites"},{"location":"install/headers/","text":"Linux Headers In order to compile the kernel version specific eBPF object, Tracee needs some of the Linux kernel headers. Depending on your Linux distribution, there may be different ways to obtain them. On Ubuntu/Debian/Arch/Manjaro install the linux-headers package. On CentOS/Fedora install the kernel-headers and kernel-devel packages. Normally the files will be installed in /lib/modules/${kernel_version}/build which is where Tracee expects them. If you have the headers elsewhere, you can set the KERN_HEADERS environment variable with the correct location. Note that it's important that the kernel headers match the exact version of the kernel you are running. To check the current kernel version, run the command uname -r . To install a specific kernel headers version append the version to the package name: linux-headers-$(uname -r) . Note that more often than not the kernel headers files contains filesystem links to other files in other directories. Therefore, when passing the kernel headers to Tracee docker container, make sure all the necessary directories are mounted. This is why the quickstart example mounts /usr/src in addition to /lib/modules .","title":"Linux Headers"},{"location":"install/headers/#linux-headers","text":"In order to compile the kernel version specific eBPF object, Tracee needs some of the Linux kernel headers. Depending on your Linux distribution, there may be different ways to obtain them. On Ubuntu/Debian/Arch/Manjaro install the linux-headers package. On CentOS/Fedora install the kernel-headers and kernel-devel packages. Normally the files will be installed in /lib/modules/${kernel_version}/build which is where Tracee expects them. If you have the headers elsewhere, you can set the KERN_HEADERS environment variable with the correct location. Note that it's important that the kernel headers match the exact version of the kernel you are running. To check the current kernel version, run the command uname -r . To install a specific kernel headers version append the version to the package name: linux-headers-$(uname -r) . Note that more often than not the kernel headers files contains filesystem links to other files in other directories. Therefore, when passing the kernel headers to Tracee docker container, make sure all the necessary directories are mounted. This is why the quickstart example mounts /usr/src in addition to /lib/modules .","title":"Linux Headers"},{"location":"install/kubernetes/","text":"Deploy on Kubernetes NOTE This approach assumes that kernel headers are available on the Kubernetes nodes under conventional location, e.g /usr/src and /lib/modules. More details about Minimal Requirements to run tracee in the Kubernetes nodes kubectl create -f deploy/kubernetes Setting Webhook ConfigMap This sample deploy use falcosidekick.tmpl and a config map for the falcosidekick settings (webhook-cm.yaml). Edit the ConfigMap with the respective values. NOTE See the complete config file in falcosidekick","title":"Deploy on Kubernetes"},{"location":"install/kubernetes/#deploy-on-kubernetes","text":"NOTE This approach assumes that kernel headers are available on the Kubernetes nodes under conventional location, e.g /usr/src and /lib/modules. More details about Minimal Requirements to run tracee in the Kubernetes nodes kubectl create -f deploy/kubernetes","title":"Deploy on Kubernetes"},{"location":"install/kubernetes/#setting-webhook-configmap","text":"This sample deploy use falcosidekick.tmpl and a config map for the falcosidekick settings (webhook-cm.yaml). Edit the ConfigMap with the respective values. NOTE See the complete config file in falcosidekick","title":"Setting Webhook ConfigMap"},{"location":"install/prerequisites/","text":"Prerequisites Portable (CO:RE) option: - Linux kernel version >= 4.18 - BTF enabled ( You can manually detect if your environments supports it by checking if the following file exists on your machine: /sys/kernel/btf/vmlinux or consult the following documentation: https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere ) Kernel version specific option: - Linux kernel version >= 4.18 - Linux kernel headers available under conventional location (see Linux Headers section for more info) - libc, and the libraries: libelf, zlib - GNU Make >= 4.3 - clang >= 11 Exceptions: Tracee supports loading a pre-compiled eBPF file, in which case the kernel headers are not required at runtime, but only for the one-time compilation of the eBPF program. See Setup Options for more info. When using Tracee's Docker image, all of the tooling is built into the image. The only requirement left is the kernel headers or the pre-built eBPF artifact. See Setup Options for more info. Permissions For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities: - CAP_SYS_RESOURCE (to manage eBPF maps limits) - CAP_BPF + CAP_TRACING which are available on recent kernels (>=5.8), or SYS_ADMIN on older kernels (to load and attach the eBPF programs). Alternatively, run as root or with the --privileged flag of Docker.","title":"Prerequisites"},{"location":"install/prerequisites/#prerequisites","text":"Portable (CO:RE) option: - Linux kernel version >= 4.18 - BTF enabled ( You can manually detect if your environments supports it by checking if the following file exists on your machine: /sys/kernel/btf/vmlinux or consult the following documentation: https://github.com/libbpf/libbpf#bpf-co-re-compile-once--run-everywhere ) Kernel version specific option: - Linux kernel version >= 4.18 - Linux kernel headers available under conventional location (see Linux Headers section for more info) - libc, and the libraries: libelf, zlib - GNU Make >= 4.3 - clang >= 11 Exceptions: Tracee supports loading a pre-compiled eBPF file, in which case the kernel headers are not required at runtime, but only for the one-time compilation of the eBPF program. See Setup Options for more info. When using Tracee's Docker image, all of the tooling is built into the image. The only requirement left is the kernel headers or the pre-built eBPF artifact. See Setup Options for more info.","title":"Prerequisites"},{"location":"install/prerequisites/#permissions","text":"For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities: - CAP_SYS_RESOURCE (to manage eBPF maps limits) - CAP_BPF + CAP_TRACING which are available on recent kernels (>=5.8), or SYS_ADMIN on older kernels (to load and attach the eBPF programs). Alternatively, run as root or with the --privileged flag of Docker.","title":"Permissions"},{"location":"tracee-ebpf/","text":"Tracing In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case you can use Tracee's eBPF collector component, which will start dumping raw data directly into standard output. Watch a quick video demo of Tracee's eBPF tracing capabilities Quickstart Before you proceed, make sure you follow the minimum requirements for running Tracee . docker run --name tracee --rm --privileged -it aquasec/tracee:latest trace Here we are running the same aquasec/tracee container, but with the trace sub-command, which will start just a raw trace (Tracee-eBPF), without the detection engine (Tracee-Rules). Here's a sample output of running with no additional arguments: TIME(s) UID COMM PID TID RET EVENT ARGS 176751.746515 1000 zsh 14726 14726 0 execve pathname: /usr/bin/ls, argv: [ls] 176751.746772 1000 zsh 14726 14726 0 security_bprm_check pathname: /usr/bin/ls, dev: 8388610, inode: 777 176751.747044 1000 ls 14726 14726 -2 access pathname: /etc/ld.so.preload, mode: R_OK 176751.747077 1000 ls 14726 14726 0 security_file_open pathname: /etc/ld.so.cache, flags: O_RDONLY|O_LARGEFILE, dev: 8388610, inode: 533737 ... Each line is a single event collected by Tracee-eBPF, with the following information: TIME - shows the event time relative to system boot time in seconds UID - real user id (in host user namespace) of the calling process COMM - name of the calling process PID - pid of the calling process TID - tid of the calling thread RET - value returned by the function EVENT - identifies the event (e.g. syscall name) ARGS - list of arguments given to the function Getting Tracee-eBPF You can obtain Tracee-eBPF in any of the following ways: 1. Download from the GitHub Releases ( tracee.tar.gz ). 2. Use the docker image from Docker Hub: aquasec/tracee with the trace sub-command. 3. Build the executable from source using make build . For that you will need additional development tooling. 4. Build the executable from source in a Docker container which includes all development tooling, using make build DOCKER=1 . All of the other setup options and considerations listed under Tracee's Installation section applies to Tracee-eBPF as well.","title":"Getting Started"},{"location":"tracee-ebpf/#tracing","text":"In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case you can use Tracee's eBPF collector component, which will start dumping raw data directly into standard output. Watch a quick video demo of Tracee's eBPF tracing capabilities","title":"Tracing"},{"location":"tracee-ebpf/#quickstart","text":"Before you proceed, make sure you follow the minimum requirements for running Tracee . docker run --name tracee --rm --privileged -it aquasec/tracee:latest trace Here we are running the same aquasec/tracee container, but with the trace sub-command, which will start just a raw trace (Tracee-eBPF), without the detection engine (Tracee-Rules). Here's a sample output of running with no additional arguments: TIME(s) UID COMM PID TID RET EVENT ARGS 176751.746515 1000 zsh 14726 14726 0 execve pathname: /usr/bin/ls, argv: [ls] 176751.746772 1000 zsh 14726 14726 0 security_bprm_check pathname: /usr/bin/ls, dev: 8388610, inode: 777 176751.747044 1000 ls 14726 14726 -2 access pathname: /etc/ld.so.preload, mode: R_OK 176751.747077 1000 ls 14726 14726 0 security_file_open pathname: /etc/ld.so.cache, flags: O_RDONLY|O_LARGEFILE, dev: 8388610, inode: 533737 ... Each line is a single event collected by Tracee-eBPF, with the following information: TIME - shows the event time relative to system boot time in seconds UID - real user id (in host user namespace) of the calling process COMM - name of the calling process PID - pid of the calling process TID - tid of the calling thread RET - value returned by the function EVENT - identifies the event (e.g. syscall name) ARGS - list of arguments given to the function","title":"Quickstart"},{"location":"tracee-ebpf/#getting-tracee-ebpf","text":"You can obtain Tracee-eBPF in any of the following ways: 1. Download from the GitHub Releases ( tracee.tar.gz ). 2. Use the docker image from Docker Hub: aquasec/tracee with the trace sub-command. 3. Build the executable from source using make build . For that you will need additional development tooling. 4. Build the executable from source in a Docker container which includes all development tooling, using make build DOCKER=1 . All of the other setup options and considerations listed under Tracee's Installation section applies to Tracee-eBPF as well.","title":"Getting Tracee-eBPF"},{"location":"tracee-ebpf/capture/","text":"Capturing Artifacts Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the --capture flag. All captured artifacts are saved in Tracee's \"output directory\" which can be configured using --capture dir:/path/to/dir . Tracee can capture the following types of artifacts: Written files: Anytime a file is being written to, the contents of the file will be captured. Written files can be filtered using an optional path prefix. Executed files: Anytime a binary is being executed, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once. Memory files: Anytime a \"memory unpacker\" is detected, the suspicious memory region will be captured. This is triggered when memory protection changes from Write+Execute to Write. Network pcap files: Anytime a packet goes through the network interface, the packet is captured into the pcap file. only packets that are generated by traced processes are being captured. CLI Options CLI Option Description [artifact:]write[=/path/prefix*] capture written files. A filter can be given to only capture file writes whose path starts with some prefix (up to 50 characters). Up to 3 filters can be given. [artifact:]exec capture executed files. [artifact:]mem capture memory regions that had write+execute (w+x) protection, and then changed to execute (x) only. [artifact:]net=<network_interface> capture network packets generated by traced processes, that goes through . Only TCP/UDP protocols are currently supported. dir:/path/to/dir path where tracee will save produced artifacts. the artifact will be saved into an 'out' subdirectory. (default: /tmp/tracee). clear-dir clear the captured artifacts output dir before starting (default: false). (Use this flag multiple times to choose multiple capture options) Examples Capture executed files into the default output directory --capture exec Delete /my/dir/out and then capture executed files into it --capture exec --capture dir:/my/dir --capture clear-dir Capture files that were written into anywhere under /usr/bin/ or /etc/ --capture write=/usr/bin/* --capture write=/etc/* Capture pcap files --capture net=enp0s3","title":"Capturing Artifacts"},{"location":"tracee-ebpf/capture/#capturing-artifacts","text":"Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the --capture flag. All captured artifacts are saved in Tracee's \"output directory\" which can be configured using --capture dir:/path/to/dir . Tracee can capture the following types of artifacts: Written files: Anytime a file is being written to, the contents of the file will be captured. Written files can be filtered using an optional path prefix. Executed files: Anytime a binary is being executed, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once. Memory files: Anytime a \"memory unpacker\" is detected, the suspicious memory region will be captured. This is triggered when memory protection changes from Write+Execute to Write. Network pcap files: Anytime a packet goes through the network interface, the packet is captured into the pcap file. only packets that are generated by traced processes are being captured.","title":"Capturing Artifacts"},{"location":"tracee-ebpf/capture/#cli-options","text":"CLI Option Description [artifact:]write[=/path/prefix*] capture written files. A filter can be given to only capture file writes whose path starts with some prefix (up to 50 characters). Up to 3 filters can be given. [artifact:]exec capture executed files. [artifact:]mem capture memory regions that had write+execute (w+x) protection, and then changed to execute (x) only. [artifact:]net=<network_interface> capture network packets generated by traced processes, that goes through . Only TCP/UDP protocols are currently supported. dir:/path/to/dir path where tracee will save produced artifacts. the artifact will be saved into an 'out' subdirectory. (default: /tmp/tracee). clear-dir clear the captured artifacts output dir before starting (default: false). (Use this flag multiple times to choose multiple capture options)","title":"CLI Options"},{"location":"tracee-ebpf/capture/#examples","text":"Capture executed files into the default output directory --capture exec Delete /my/dir/out and then capture executed files into it --capture exec --capture dir:/my/dir --capture clear-dir Capture files that were written into anywhere under /usr/bin/ or /etc/ --capture write=/usr/bin/* --capture write=/etc/* Capture pcap files --capture net=enp0s3","title":"Examples"},{"location":"tracee-ebpf/output/","text":"Output Options Control how and where output is printed. CLI Options CLI Option Description [format:]{table,table-verbose,json,gob,gotemplate=/path/to/template} output events in the specified format. for gotemplate, specify the mandatory template file none ignore stream of events output, usually used with --capture out-file:/path/to/file write the output to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stdout) err-file:/path/to/file write the errors to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stderr) option:{stack-addresses,detect-syscall,exec-env} augment output according to given options (default: none) stack-addresses include stack memory addresses for each event detect-syscall when tracing kernel functions which are not syscalls, detect and show the original syscall that called that function exec-env when tracing execve/execveat, show the environment variables that were used for execution (Use this flag multiple times to choose multiple capture options) Examples output as json --output json output as the provided go template --output gotemplate=/path/to/my.tmpl output to /my/out and errors to /my/err --output out-file:/my/out err-file:/my/err","title":"Output Options"},{"location":"tracee-ebpf/output/#output-options","text":"Control how and where output is printed.","title":"Output Options"},{"location":"tracee-ebpf/output/#cli-options","text":"CLI Option Description [format:]{table,table-verbose,json,gob,gotemplate=/path/to/template} output events in the specified format. for gotemplate, specify the mandatory template file none ignore stream of events output, usually used with --capture out-file:/path/to/file write the output to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stdout) err-file:/path/to/file write the errors to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stderr) option:{stack-addresses,detect-syscall,exec-env} augment output according to given options (default: none) stack-addresses include stack memory addresses for each event detect-syscall when tracing kernel functions which are not syscalls, detect and show the original syscall that called that function exec-env when tracing execve/execveat, show the environment variables that were used for execution (Use this flag multiple times to choose multiple capture options)","title":"CLI Options"},{"location":"tracee-ebpf/output/#examples","text":"output as json --output json output as the provided go template --output gotemplate=/path/to/my.tmpl output to /my/out and errors to /my/err --output out-file:/my/out err-file:/my/err","title":"Examples"},{"location":"tracee-ebpf/trace-options/","text":"Trace Options Trace output can easily become unwieldy when tracing all of the events from all of the system. Luckily, Tracee has a powerful mechanism to accurately trace just the information that is relevant to you, using the --trace flag. Using the --trace you define expressions that tells Tracee-eBPF what you are interested in by means of event metadata, and process metadata. Only events that match this criteria will be traced. You can filter by most of the visible fields on a Tracee event. For example to trace only events related to user ID 1000, use --trace uid=1000 . You can combine trace expressions into more complex criteria. For example, to trace only events related to user ID 1000, which come from process ID 1234, use --trace uid=1000 --trace pid=1234 . A special pid value is new which let's you trace all newly created processes (that were created after Tracee started tracing). Tracee-eBPF lets you easily trace events that originate in containers using --trace container or only new containers (that were created after Tracee started) using --trace container=new . Event metadata can be used in trace expression as well. For example, to trace only openat syscalls, use --trace event:openat . But you can also filter on a specific argument of the event, e.g --trace openat.pathname=/bin/ls which will show only openat syscalls that operate on the file /bin/ls . A useful trace mode is the --trace follow which, if specified, will trace not only processes that match the given trace expressions, but also their child processes. For example, the following will trace all the events that originate from zsh shell, including all of the processes that it will spawn: --trace command=zsh --follow . CLI Options Only events that match all trace expressions will be traced (trace flags are ANDed). The following types of expressions are supported: Numerical expressions which compare numbers and allow the following operators: '=', '!=', '<', '>'. Available numerical expressions: uid, pid, mntns, pidns. String expressions which compares text and allow the following operators: '=', '!='. Available string expressions: event, set, uts, comm. Boolean expressions that check if a boolean is true and allow the following operator: '!'. Available boolean expressions: container. Event arguments can be accessed using 'event_name.event_arg' and provide a way to filter an event by its arguments. Event arguments allow the following operators: '=', '!='. Strings can be compared as a prefix if ending with '*'. Event return value can be accessed using 'event_name.retval' and provide a way to filter an event by its return value. Event return value expression has the same syntax as a numerical expression. Non-boolean expressions can compare a field to multiple values separated by ','. Multiple values are ORed if used with equals operator '=', but are ANDed if used with any other operator. The field 'container' and 'pid' also support the special value 'new' which selects new containers or pids, respectively. The field 'set' selects a set of events to trace according to predefined sets, which can be listed by using the 'list' flag. The special 'follow' expression declares that not only processes that match the criteria will be traced, but also their descendants. Note: some of the above operators have special meanings in different shells. To 'escape' those operators, please use single quotes, e.g.: 'uid>0' Examples only trace events from new processes --trace pid=new only trace events from pid 510 or pid 1709 --trace pid=510,1709 only trace events from pid 510 or pid 1709 (same as above) --trace p=510 --trace p=1709 only trace events from newly created containers --trace container=new only trace events from containers --trace container only trace events from containers (same as above) --trace c only trace events from the host --trace '!container' only trace events from uid 0 --trace uid=0 only trace events from mntns id 4026531840 --trace mntns=4026531840 only trace events from pidns id not equal to 4026531840 --trace pidns!=4026531836 only trace events from uids greater than 0 --trace 'uid>0' only trace events from pids between 0 and 1000 --trace 'pid>0' --trace 'pid<1000' only trace events from uids greater than 0 but not 1000 --trace 'u>0' --trace u!=1000 only trace execve and open events --trace event=execve,open only trace events prefixed by \"open\" --trace event=open* don't trace events prefixed by \"open\" or \"dup\" --trace event!=open*,dup* trace all file-system related events --trace set=fs trace all file-system related events, but not open(at) --trace s=fs --trace e!=open,openat don't trace events from uts name ab356bc4dd554 --trace uts!=ab356bc4dd554 only trace events from ls command --trace comm=ls only trace 'close' events that have 'fd' equals 5 --trace close.fd=5 only trace 'openat' events that have 'pathname' prefixed by \"/tmp\" --trace openat.pathname=/tmp* don't trace 'openat' events that have 'pathname' equals /tmp/1 or /bin/ls --trace openat.pathname!=/tmp/1,/bin/ls trace all events that originated from bash or from one of the processes spawned by bash --trace comm=bash --trace follow","title":"Trace Options"},{"location":"tracee-ebpf/trace-options/#trace-options","text":"Trace output can easily become unwieldy when tracing all of the events from all of the system. Luckily, Tracee has a powerful mechanism to accurately trace just the information that is relevant to you, using the --trace flag. Using the --trace you define expressions that tells Tracee-eBPF what you are interested in by means of event metadata, and process metadata. Only events that match this criteria will be traced. You can filter by most of the visible fields on a Tracee event. For example to trace only events related to user ID 1000, use --trace uid=1000 . You can combine trace expressions into more complex criteria. For example, to trace only events related to user ID 1000, which come from process ID 1234, use --trace uid=1000 --trace pid=1234 . A special pid value is new which let's you trace all newly created processes (that were created after Tracee started tracing). Tracee-eBPF lets you easily trace events that originate in containers using --trace container or only new containers (that were created after Tracee started) using --trace container=new . Event metadata can be used in trace expression as well. For example, to trace only openat syscalls, use --trace event:openat . But you can also filter on a specific argument of the event, e.g --trace openat.pathname=/bin/ls which will show only openat syscalls that operate on the file /bin/ls . A useful trace mode is the --trace follow which, if specified, will trace not only processes that match the given trace expressions, but also their child processes. For example, the following will trace all the events that originate from zsh shell, including all of the processes that it will spawn: --trace command=zsh --follow .","title":"Trace Options"},{"location":"tracee-ebpf/trace-options/#cli-options","text":"Only events that match all trace expressions will be traced (trace flags are ANDed). The following types of expressions are supported: Numerical expressions which compare numbers and allow the following operators: '=', '!=', '<', '>'. Available numerical expressions: uid, pid, mntns, pidns. String expressions which compares text and allow the following operators: '=', '!='. Available string expressions: event, set, uts, comm. Boolean expressions that check if a boolean is true and allow the following operator: '!'. Available boolean expressions: container. Event arguments can be accessed using 'event_name.event_arg' and provide a way to filter an event by its arguments. Event arguments allow the following operators: '=', '!='. Strings can be compared as a prefix if ending with '*'. Event return value can be accessed using 'event_name.retval' and provide a way to filter an event by its return value. Event return value expression has the same syntax as a numerical expression. Non-boolean expressions can compare a field to multiple values separated by ','. Multiple values are ORed if used with equals operator '=', but are ANDed if used with any other operator. The field 'container' and 'pid' also support the special value 'new' which selects new containers or pids, respectively. The field 'set' selects a set of events to trace according to predefined sets, which can be listed by using the 'list' flag. The special 'follow' expression declares that not only processes that match the criteria will be traced, but also their descendants. Note: some of the above operators have special meanings in different shells. To 'escape' those operators, please use single quotes, e.g.: 'uid>0'","title":"CLI Options"},{"location":"tracee-ebpf/trace-options/#examples","text":"only trace events from new processes --trace pid=new only trace events from pid 510 or pid 1709 --trace pid=510,1709 only trace events from pid 510 or pid 1709 (same as above) --trace p=510 --trace p=1709 only trace events from newly created containers --trace container=new only trace events from containers --trace container only trace events from containers (same as above) --trace c only trace events from the host --trace '!container' only trace events from uid 0 --trace uid=0 only trace events from mntns id 4026531840 --trace mntns=4026531840 only trace events from pidns id not equal to 4026531840 --trace pidns!=4026531836 only trace events from uids greater than 0 --trace 'uid>0' only trace events from pids between 0 and 1000 --trace 'pid>0' --trace 'pid<1000' only trace events from uids greater than 0 but not 1000 --trace 'u>0' --trace u!=1000 only trace execve and open events --trace event=execve,open only trace events prefixed by \"open\" --trace event=open* don't trace events prefixed by \"open\" or \"dup\" --trace event!=open*,dup* trace all file-system related events --trace set=fs trace all file-system related events, but not open(at) --trace s=fs --trace e!=open,openat don't trace events from uts name ab356bc4dd554 --trace uts!=ab356bc4dd554 only trace events from ls command --trace comm=ls only trace 'close' events that have 'fd' equals 5 --trace close.fd=5 only trace 'openat' events that have 'pathname' prefixed by \"/tmp\" --trace openat.pathname=/tmp* don't trace 'openat' events that have 'pathname' equals /tmp/1 or /bin/ls --trace openat.pathname!=/tmp/1,/bin/ls trace all events that originated from bash or from one of the processes spawned by bash --trace comm=bash --trace follow","title":"Examples"}]}