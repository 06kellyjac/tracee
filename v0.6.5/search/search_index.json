{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Tracee: Runtime Security and Forensics using eBPF \u00b6 Tracee is a Runtime Security and forensics tool for Linux. It is using Linux eBPF technology to trace your system and applications at runtime, and analyze collected events to detect suspicious behavioral patterns. It is delivered as a Docker image that monitors the OS and detects suspicious behavior based on a predefined set of behavioral patterns. Watch a quick video demo of Tracee: Check out the Tracee video hub for more videos. Quickstart \u00b6 Before you proceed, make sure you follow the minimum requirements for running Tracee . Running tracee:latest docker run \\ --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ aquasec/tracee:0.7.0 Running tracee:full docker run --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ -v /usr/src:/usr/src:ro \\ -v /lib/modules:/lib/modules:ro \\ -v /tmp/tracee:/tmp/tracee:rw \\ aquasec/tracee:full-0.7.0 Note The default (latest) image is lightweight and portable . It is supposed to support different kernel versions without having to build source code. If the host kernel does not support BTF then you may use the full container image. The full container will compile an eBPF object during startup, if you do not have one already cached in /tmp/tracee . Note You may need to change the volume mounts for the kernel headers based on your setup. See Linux Headers section for more info. This will run Tracee with default settings and start reporting detections to standard output. In order to simulate a suspicious behavior, you can simply run: strace ls in another terminal. This will trigger the \"Anti-Debugging\" signature, which is loaded by default, and you will get a warning: INFO: probing tracee-ebpf capabilities... INFO: starting tracee-ebpf... INFO: starting tracee-rules... Loaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7] Serving metrics endpoint at :3366 Serving metrics endpoint at :4466 *** Detection *** Time: 2022-03-25T08:04:22Z Signature ID: TRC-2 Signature: Anti-Debugging Data: map[] Command: strace Hostname: ubuntu-impish Trace \u00b6 In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case, you can run tracee exporting TRACEE_EBPF_ONLY=1 environment variable. docker run \\ --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ -e TRACEE_EBPF_ONLY = 1 \\ aquasec/tracee:0.7.0 Note See documentation or add the --help flag for more. Components \u00b6 Tracee is composed of the following sub-projects, which are hosted in the aquasecurity/tracee repository: Tracee-eBPF - Linux Tracing and Forensics using eBPF Tracee-Rules - Runtime Security Detection Engine Tracee is an Aqua Security open source project. Learn about our open source work and portfolio Here . Join the community, and talk to us about any matter in GitHub Discussion or Slack .","title":"Getting Started"},{"location":"#tracee-runtime-security-and-forensics-using-ebpf","text":"Tracee is a Runtime Security and forensics tool for Linux. It is using Linux eBPF technology to trace your system and applications at runtime, and analyze collected events to detect suspicious behavioral patterns. It is delivered as a Docker image that monitors the OS and detects suspicious behavior based on a predefined set of behavioral patterns. Watch a quick video demo of Tracee: Check out the Tracee video hub for more videos.","title":"Tracee: Runtime Security and Forensics using eBPF"},{"location":"#quickstart","text":"Before you proceed, make sure you follow the minimum requirements for running Tracee . Running tracee:latest docker run \\ --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ aquasec/tracee:0.7.0 Running tracee:full docker run --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ -v /usr/src:/usr/src:ro \\ -v /lib/modules:/lib/modules:ro \\ -v /tmp/tracee:/tmp/tracee:rw \\ aquasec/tracee:full-0.7.0 Note The default (latest) image is lightweight and portable . It is supposed to support different kernel versions without having to build source code. If the host kernel does not support BTF then you may use the full container image. The full container will compile an eBPF object during startup, if you do not have one already cached in /tmp/tracee . Note You may need to change the volume mounts for the kernel headers based on your setup. See Linux Headers section for more info. This will run Tracee with default settings and start reporting detections to standard output. In order to simulate a suspicious behavior, you can simply run: strace ls in another terminal. This will trigger the \"Anti-Debugging\" signature, which is loaded by default, and you will get a warning: INFO: probing tracee-ebpf capabilities... INFO: starting tracee-ebpf... INFO: starting tracee-rules... Loaded 14 signature(s): [TRC-1 TRC-13 TRC-2 TRC-14 TRC-3 TRC-11 TRC-9 TRC-4 TRC-5 TRC-12 TRC-8 TRC-6 TRC-10 TRC-7] Serving metrics endpoint at :3366 Serving metrics endpoint at :4466 *** Detection *** Time: 2022-03-25T08:04:22Z Signature ID: TRC-2 Signature: Anti-Debugging Data: map[] Command: strace Hostname: ubuntu-impish","title":"Quickstart"},{"location":"#trace","text":"In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case, you can run tracee exporting TRACEE_EBPF_ONLY=1 environment variable. docker run \\ --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ -e TRACEE_EBPF_ONLY = 1 \\ aquasec/tracee:0.7.0 Note See documentation or add the --help flag for more.","title":"Trace"},{"location":"#components","text":"Tracee is composed of the following sub-projects, which are hosted in the aquasecurity/tracee repository: Tracee-eBPF - Linux Tracing and Forensics using eBPF Tracee-Rules - Runtime Security Detection Engine Tracee is an Aqua Security open source project. Learn about our open source work and portfolio Here . Join the community, and talk to us about any matter in GitHub Discussion or Slack .","title":"Components"},{"location":"architecture/","text":"Architecture \u00b6 High level overview \u00b6","title":"Architecture"},{"location":"architecture/#architecture","text":"","title":"Architecture"},{"location":"architecture/#high-level-overview","text":"","title":"High level overview"},{"location":"config/","text":"Configuration Options \u00b6 By default, rules are discovered from the rules directory next to the tracee-rules executable binary (you can specify a different location with the --rules-dir flag). By default, all discovered rules will be loaded unless specific rules are selected using the --rules flag.","title":"Configuration Options"},{"location":"config/#configuration-options","text":"By default, rules are discovered from the rules directory next to the tracee-rules executable binary (you can specify a different location with the --rules-dir flag). By default, all discovered rules will be loaded unless specific rules are selected using the --rules flag.","title":"Configuration Options"},{"location":"faq/","text":"FAQ - Frequently Asked Questions \u00b6 Secure tracing \u00b6 When Tracee-eBPF reads information from user programs it is subject to a race condition where the user program might be able to change the arguments after Tracee has read them. For example, a program invoked execve(\"/bin/ls\", NULL, 0) , Tracee picked that up and will report that, then the program changed the first argument from /bin/ls to /bin/bash , and this is what the kernel will execute. To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the bprm_check event which can be reported by Tracee and cross-referenced with the reported regular syscall event.","title":"FAQ"},{"location":"faq/#faq-frequently-asked-questions","text":"","title":"FAQ - Frequently Asked Questions"},{"location":"faq/#secure-tracing","text":"When Tracee-eBPF reads information from user programs it is subject to a race condition where the user program might be able to change the arguments after Tracee has read them. For example, a program invoked execve(\"/bin/ls\", NULL, 0) , Tracee picked that up and will report that, then the program changed the first argument from /bin/ls to /bin/bash , and this is what the kernel will execute. To mitigate this, Tracee also provides \"LSM\" (Linux Security Module) based events, for example, the bprm_check event which can be reported by Tracee and cross-referenced with the reported regular syscall event.","title":"Secure tracing"},{"location":"integrations/","text":"Integrations \u00b6 When a detection is made by any of the signatures, it will always be printed to stdout. You can customize the output format using a go template : tracee-rules --output-template /path/to/my.tmpl In addition, Tracee can notify a web service when a detection is made using a custom webhook: tracee-rules --webhook http://my.webhook/endpoint \\ --webhook-template /path/to/my.tmpl \\ --webhook-content-type application/json Included Go templates \u00b6 The following Go templates are included in the Tracee container image and are available for use under the /tracee/templates/ directory in the container: File name Description Content-Type Source falcosidekick.tmpl For compatibility with falcosidekick application/json source rawjson.tmpl Dumps the Finding object as raw JSON application/json source Go Template Authoring \u00b6 When authoring a Go template for either stdout or webhook, you have Tracee's types.Finding struct as the data source: //Finding is the main output of a signature. It represents a match result for the signature business logic type Finding struct { SigMetadata SignatureMetadata //information about the signature that made the detection Context Event //the raw event that triggered the detection Data map [ string ] interface {} //detection specific information } The Go template can utilize helper functions from Sprig . For example templates, see tracee/cmd/tracee-rules/templates . Prometheus \u00b6 Tracee is enabled for prometheus scraping by default. Scraping can be done through the following URLs:1 1. tracee-ebpf can be scraped through :3366/metrics 2. tracee-rules can be scraped through :4466/metrics The metrics addresses can be changed through running with the metrics and metrics-addr in the cli. Examples \u00b6 Raw JSON stdout \u00b6 The following example configures Tracee to output detections to stdout as raw JSON: docker run --rm -it --privileged --pid = host --cgroupns = host \\ -v /lib/modules/:/lib/modules/:ro \\ -v /usr/src:/usr/src:ro \\ -v /tmp/tracee:/tmp/tracee \\ aquasec/tracee:0.7.0 \\ --output-template /tracee/templates/rawjson.tmpl falcosidekick webhook \u00b6 falcosidekick is a useful webhook server that can be configured to connect to various \"outputs\" such as: Slack, Mattermost, Teams, Datadog, Prometheus, StatsD, Email, Elasticsearch, Loki, PagerDuty, OpsGenie, and many more. To use Tracee with falcosidekick: Obtain connection credentials to the system you want to integrate with. Consult the system's documentation and look for how to configure an incoming webhook. Start the falcosidekick container, configured with the obtained output credentials: See the falcosidekick Readme for full documentation. Start Tracee while configuring it to post detections to the falcosidekick endpoint. If using Docker, you can use the simple link flag to allow the containers to communicate Use the webhook flag to point to the falcosidekick container's endpoint Tracee ships with a built-in template for falcosidekick # Start falcosidekick configured to post to Slack docker run --name falcosidekick -p 2801 :2801 \\ -e SLACK_WEBHOOKURL = https://hooks.slack.com/services/XXX/YYY/ZZZ \\ falcosecurity/falcosidekick # Start Tracee, linking it to the falcosidekick container, and configuring it to call it on detections docker run --name tracee --rm -it --privileged --pid = host --cgroupns = host \\ -v /lib/modules/:/lib/modules/:ro \\ -v /usr/src:/usr/src:ro \\ -v /tmp/tracee:/tmp/tracee \\ --link falcosidekick aquasec/tracee:0.7.0 \\ --webhook-template /tracee/templates/falcosidekick.tmpl \\ --webhook-content-type application/json \\ --webhook http://FALCOSIDEKICK:2801","title":"Integrations"},{"location":"integrations/#integrations","text":"When a detection is made by any of the signatures, it will always be printed to stdout. You can customize the output format using a go template : tracee-rules --output-template /path/to/my.tmpl In addition, Tracee can notify a web service when a detection is made using a custom webhook: tracee-rules --webhook http://my.webhook/endpoint \\ --webhook-template /path/to/my.tmpl \\ --webhook-content-type application/json","title":"Integrations"},{"location":"integrations/#included-go-templates","text":"The following Go templates are included in the Tracee container image and are available for use under the /tracee/templates/ directory in the container: File name Description Content-Type Source falcosidekick.tmpl For compatibility with falcosidekick application/json source rawjson.tmpl Dumps the Finding object as raw JSON application/json source","title":"Included Go templates"},{"location":"integrations/#go-template-authoring","text":"When authoring a Go template for either stdout or webhook, you have Tracee's types.Finding struct as the data source: //Finding is the main output of a signature. It represents a match result for the signature business logic type Finding struct { SigMetadata SignatureMetadata //information about the signature that made the detection Context Event //the raw event that triggered the detection Data map [ string ] interface {} //detection specific information } The Go template can utilize helper functions from Sprig . For example templates, see tracee/cmd/tracee-rules/templates .","title":"Go Template Authoring"},{"location":"integrations/#prometheus","text":"Tracee is enabled for prometheus scraping by default. Scraping can be done through the following URLs:1 1. tracee-ebpf can be scraped through :3366/metrics 2. tracee-rules can be scraped through :4466/metrics The metrics addresses can be changed through running with the metrics and metrics-addr in the cli.","title":"Prometheus"},{"location":"integrations/#examples","text":"","title":"Examples"},{"location":"integrations/#raw-json-stdout","text":"The following example configures Tracee to output detections to stdout as raw JSON: docker run --rm -it --privileged --pid = host --cgroupns = host \\ -v /lib/modules/:/lib/modules/:ro \\ -v /usr/src:/usr/src:ro \\ -v /tmp/tracee:/tmp/tracee \\ aquasec/tracee:0.7.0 \\ --output-template /tracee/templates/rawjson.tmpl","title":"Raw JSON stdout"},{"location":"integrations/#falcosidekick-webhook","text":"falcosidekick is a useful webhook server that can be configured to connect to various \"outputs\" such as: Slack, Mattermost, Teams, Datadog, Prometheus, StatsD, Email, Elasticsearch, Loki, PagerDuty, OpsGenie, and many more. To use Tracee with falcosidekick: Obtain connection credentials to the system you want to integrate with. Consult the system's documentation and look for how to configure an incoming webhook. Start the falcosidekick container, configured with the obtained output credentials: See the falcosidekick Readme for full documentation. Start Tracee while configuring it to post detections to the falcosidekick endpoint. If using Docker, you can use the simple link flag to allow the containers to communicate Use the webhook flag to point to the falcosidekick container's endpoint Tracee ships with a built-in template for falcosidekick # Start falcosidekick configured to post to Slack docker run --name falcosidekick -p 2801 :2801 \\ -e SLACK_WEBHOOKURL = https://hooks.slack.com/services/XXX/YYY/ZZZ \\ falcosecurity/falcosidekick # Start Tracee, linking it to the falcosidekick container, and configuring it to call it on detections docker run --name tracee --rm -it --privileged --pid = host --cgroupns = host \\ -v /lib/modules/:/lib/modules/:ro \\ -v /usr/src:/usr/src:ro \\ -v /tmp/tracee:/tmp/tracee \\ --link falcosidekick aquasec/tracee:0.7.0 \\ --webhook-template /tracee/templates/falcosidekick.tmpl \\ --webhook-content-type application/json \\ --webhook http://FALCOSIDEKICK:2801","title":"falcosidekick webhook"},{"location":"rules-authoring/","text":"Authoring Rules \u00b6 Tracee supports authoring rules in Golang) or in Rego (the language of Open Policy Agent ). Rego Rules \u00b6 Create a .rego file in the rules directory that has the following Rego Rules (in this context rules are Rego's language constructs): __rego_metadoc__ : A document rule that defines the rule's metadata. tracee_selected_events : A set rule that defines the event selectors. tracee_match : A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\". See signatures/rego for example Rego signatures. Golang Rules \u00b6 Tracee exports a Signature interface that you can implement. We use Go Plugins to load Go signatures. Create a new Go project with a package main . Import github.com/aquasecurity/tracee/types and implement the types.Signature interface. Export a package level variable called ExportedSignatures of type []types.Signature that declares the implemented signature (or more) that your package exports. Compile using goplugins go build -buildmode=plugin -o yourplugin.so yoursource.go . Place the resulting compiled file in the rules directory, and it will be automatically discovered by Tracee. See signatures/golang/examples for example Go signatures.","title":"Authoring Rules"},{"location":"rules-authoring/#authoring-rules","text":"Tracee supports authoring rules in Golang) or in Rego (the language of Open Policy Agent ).","title":"Authoring Rules"},{"location":"rules-authoring/#rego-rules","text":"Create a .rego file in the rules directory that has the following Rego Rules (in this context rules are Rego's language constructs): __rego_metadoc__ : A document rule that defines the rule's metadata. tracee_selected_events : A set rule that defines the event selectors. tracee_match : A boolean or a document rule that defines the logic of the signature. If bool is \"returned\", a true evaluation will generate a Finding with no data. If a document is \"returned\", any non-empty evaluation will generate a Finding with the returned document as the Finding's \"Data\". See signatures/rego for example Rego signatures.","title":"Rego Rules"},{"location":"rules-authoring/#golang-rules","text":"Tracee exports a Signature interface that you can implement. We use Go Plugins to load Go signatures. Create a new Go project with a package main . Import github.com/aquasecurity/tracee/types and implement the types.Signature interface. Export a package level variable called ExportedSignatures of type []types.Signature that declares the implemented signature (or more) that your package exports. Compile using goplugins go build -buildmode=plugin -o yourplugin.so yoursource.go . Place the resulting compiled file in the rules directory, and it will be automatically discovered by Tracee. See signatures/golang/examples for example Go signatures.","title":"Golang Rules"},{"location":"rules-index/","text":"Available Rules \u00b6 To view the list of available rules, run Tracee with the --list flag. We are currently working on creating a library of behavioral signature detections. Currently, the following are available: Name Description Tags Standard Input/Output Over Socket Redirection of process's standard input/output to socket \"linux\", \"container\" Anti-Debugging Process uses anti-debugging technique to block debugger \"linux\", \"container\" Code injection Possible code injection into another process \"linux\", \"container\" Dynamic Code Loading Writing to executable allocated memory region \"linux\", \"container\" Fileless Execution Executing a process from memory, without a file in the disk \"linux\", \"container\" kernel module loading Attempt to load a kernel module detection \"linux\", \"container\" LD_PRELOAD Usage of LD_PRELOAD to allow hooks on process \"linux\", \"container\" Container Host Mount Mounting of the host filesystem into a container \"container\" Dropped Executable Creation or dropping of an executable file from a container at runtime \"linux\", \"container\" Illegitimate Shell Spawning of a shell program \"linux\", \"container\" K8S API Connection Connection to the Kubernetes cluster API server \"container\" K8S Service Account Use Reading of the Kubernetes service account token file in a container \"container\" K8S TLS Certificate Theft Accessing of the TLS certificate used for secure communication between Kubernetes components \"linux\", \"container\"","title":"Available Rules"},{"location":"rules-index/#available-rules","text":"To view the list of available rules, run Tracee with the --list flag. We are currently working on creating a library of behavioral signature detections. Currently, the following are available: Name Description Tags Standard Input/Output Over Socket Redirection of process's standard input/output to socket \"linux\", \"container\" Anti-Debugging Process uses anti-debugging technique to block debugger \"linux\", \"container\" Code injection Possible code injection into another process \"linux\", \"container\" Dynamic Code Loading Writing to executable allocated memory region \"linux\", \"container\" Fileless Execution Executing a process from memory, without a file in the disk \"linux\", \"container\" kernel module loading Attempt to load a kernel module detection \"linux\", \"container\" LD_PRELOAD Usage of LD_PRELOAD to allow hooks on process \"linux\", \"container\" Container Host Mount Mounting of the host filesystem into a container \"container\" Dropped Executable Creation or dropping of an executable file from a container at runtime \"linux\", \"container\" Illegitimate Shell Spawning of a shell program \"linux\", \"container\" K8S API Connection Connection to the Kubernetes cluster API server \"container\" K8S Service Account Use Reading of the Kubernetes service account token file in a container \"container\" K8S TLS Certificate Theft Accessing of the TLS certificate used for secure communication between Kubernetes components \"linux\", \"container\"","title":"Available Rules"},{"location":"building/containers/","text":"Creating Tracee Container Images \u00b6 These instructions are meant to describe how to build the official tracee containers images, instead of just downloading them from the Docker Hub . If you would like to have a local building and execution environment, read this instead. Generating Tracee Containers \u00b6 Tracee containers come in 2 flavors : tracee:latest (CO-RE enabled embedded tracee bpf object) BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee tracee:full (Contains tracee bpf source code and compiler tool chain) BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee-full Note BTFHUB=1 adds support to some older kernels so user doesn't need to build specific non CO-RE eBPF objects to them. Running Tracee Containers \u00b6 Containers are supposed to be executed through docker cmdline directly, from the official built images. Nevertheless, during the image building process, it may be useful to execute them with correct arguments to see if they're working. User may execute built containers through Makefile.tracee-container file with the \"run\" targets: To run the tracee:latest container: make -f builder/Makefile.tracee-container run-tracee To run the tracee:full container: make -f builder/Makefile.tracee-container run-tracee-full Note Tracee-ebpf arguments are passed through the ARG variable: make -f builder/Makefile.tracee-container run-tracee ARG=\"--help\" Running Tracee-eBPF Only \u00b6 Generated containers allow user to run Tracee, as a complete security solution ( tracee-ebpf passes events to tracee-rules and tracee-rules process events based on existing security signatures) or to run tracee-ebpf only, as an introspection tool. To run the tracee:latest container with tracee-ebpf only: make -f builder/Makefile.tracee-container run-tracee-ebpf To run the tracee:full container with tracee-ebpf only: make -f builder/Makefile.tracee-container run-tracee-ebpf-full Note Tracee-ebpf arguments are passed through the ARG variable: make -f builder/Makefile.tracee-container run-tracee-ebpf ARG=\"--debug\"","title":"Building Containers"},{"location":"building/containers/#creating-tracee-container-images","text":"These instructions are meant to describe how to build the official tracee containers images, instead of just downloading them from the Docker Hub . If you would like to have a local building and execution environment, read this instead.","title":"Creating Tracee Container Images"},{"location":"building/containers/#generating-tracee-containers","text":"Tracee containers come in 2 flavors : tracee:latest (CO-RE enabled embedded tracee bpf object) BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee tracee:full (Contains tracee bpf source code and compiler tool chain) BTFHUB={0,1} make -f builder/Makefile.tracee-container build-tracee-full Note BTFHUB=1 adds support to some older kernels so user doesn't need to build specific non CO-RE eBPF objects to them.","title":"Generating Tracee Containers"},{"location":"building/containers/#running-tracee-containers","text":"Containers are supposed to be executed through docker cmdline directly, from the official built images. Nevertheless, during the image building process, it may be useful to execute them with correct arguments to see if they're working. User may execute built containers through Makefile.tracee-container file with the \"run\" targets: To run the tracee:latest container: make -f builder/Makefile.tracee-container run-tracee To run the tracee:full container: make -f builder/Makefile.tracee-container run-tracee-full Note Tracee-ebpf arguments are passed through the ARG variable: make -f builder/Makefile.tracee-container run-tracee ARG=\"--help\"","title":"Running Tracee Containers"},{"location":"building/containers/#running-tracee-ebpf-only","text":"Generated containers allow user to run Tracee, as a complete security solution ( tracee-ebpf passes events to tracee-rules and tracee-rules process events based on existing security signatures) or to run tracee-ebpf only, as an introspection tool. To run the tracee:latest container with tracee-ebpf only: make -f builder/Makefile.tracee-container run-tracee-ebpf To run the tracee:full container with tracee-ebpf only: make -f builder/Makefile.tracee-container run-tracee-ebpf-full Note Tracee-ebpf arguments are passed through the ARG variable: make -f builder/Makefile.tracee-container run-tracee-ebpf ARG=\"--debug\"","title":"Running Tracee-eBPF Only"},{"location":"building/environment/","text":"Creating a local building environment \u00b6 These instructions are meant to describe how to create a local building and execution environment. If you would like to build tracee container(s) image(s), read this instead. Quick steps ( impatient readers ) \u00b6 Build and execute tracee-ebpf : $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-shell tracee@f64bb4a2f0b1[/tracee]$ make clean tracee@f64bb4a2f0b1[/tracee]$ make tracee-ebpf tracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\ -o option:parse-arguments \\ --trace comm=bash \\ --trace follow \\ --trace event!='sched*' Now, in your host's bash shell, execute a command. You will see all events (except scheduler ones) being printed, in \"table format\", to stdout. Build and execute tracee : $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-shell tracee@f64bb4a2f0b1[/tracee]$ make clean tracee@f64bb4a2f0b1[/tracee]$ make all tracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\ -o format:json \\ -o option:parse-arguments \\ --trace comm=bash \\ --trace follow \\ --trace event!='sched*' | \\ ./dist/tracee-rules \\ --input-tracee file:stdin \\ --input-tracee format:json Now, in your host's bash shell, execute: sudo strace /bin/ls and observe tracee warning you about a possible risk (with its Anti-Debugging signature). Now, for more patient readers ... How to build and use the environment \u00b6 In order to have a controlled building environment for tracee, tracee provides a Makefile.tracee-make file that allows you to create and use docker controlled environments to build & test tracee-ebpf and tracee-rules . Two different environments are maintained for building tracee: Alpine Ubuntu The reason for that is that Alpine Linux is based in the musl C standard library, while the Ubuntu Linux uses glibc . By supporting both building environments we can always be sure that the project builds (and executes) correctly in both environments. Be aware: locally created containers, called alpine-tracee-make or ubuntu-tracee-make , share the host source code directory. This means that, if you build tracee binaries using alpine distribution, binaries tracee-ebpf and tracee-rules might not be compatible to the Linux distribution from your host OS. Creating a builder environment \u00b6 To create an alpine-tracee-make container: $ make -f builder/Makefile.tracee-make alpine-prepare To create an ubuntu-tracee-make container: $ make -f builder/Makefile.tracee-make ubuntu-prepare Executing a builder environment \u00b6 To execute an alpine-tracee-make shell: $ make -f builder/Makefile.tracee-make alpine-shell To execute an ubuntu-tracee-make shell: $ make -f builder/Makefile.tracee-make ubuntu-shell Using build environment as a make replacement \u00b6 Instead of executing a builder shell, you may use alpine-tracee-make , or ubuntu-tracee-make , as a replacement for the make command: $ make -f builder/Makefile.tracee-make ubuntu-prepare $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"help\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"clean\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"bpf-core\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"tracee-ebpf\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"all\" And, after the compilation, run the commands directly in your host: $ sudo ./dist/tracee-ebpf \\ -o option:parse-arguments \\ --trace comm=bash \\ --trace follow \\ --trace event!='sched*' Note : the generated binary must be compatible to your host (depending on glibc version, for example). If you don't want to depend on host's libraries versions, or if you are using the alpine-tracee-make container as a replacement for make , and your host is not an Alpine Linux , then you may set STATIC=1 variable so you can run compiled binaries in your host: $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-make ARG=\"help\" $ STATIC=1 make -f builder/Makefile.tracee-make alpine-make ARG=\"all\" and execute the static binary from your host: $ ldd dist/tracee-ebpf not a dynamic executable Warning : compiling tracee-rules with STATIC=1 won't allow you to use golang based signatures: 2021/12/13 13:27:21 error opening plugin /tracee/dist/rules/builtin.so: plugin.Open(\"/tracee/dist/rules/builtin.so\"): Dynamic loading not supported","title":"Building Environment"},{"location":"building/environment/#creating-a-local-building-environment","text":"These instructions are meant to describe how to create a local building and execution environment. If you would like to build tracee container(s) image(s), read this instead.","title":"Creating a local building environment"},{"location":"building/environment/#quick-steps-impatient-readers","text":"Build and execute tracee-ebpf : $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-shell tracee@f64bb4a2f0b1[/tracee]$ make clean tracee@f64bb4a2f0b1[/tracee]$ make tracee-ebpf tracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\ -o option:parse-arguments \\ --trace comm=bash \\ --trace follow \\ --trace event!='sched*' Now, in your host's bash shell, execute a command. You will see all events (except scheduler ones) being printed, in \"table format\", to stdout. Build and execute tracee : $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-shell tracee@f64bb4a2f0b1[/tracee]$ make clean tracee@f64bb4a2f0b1[/tracee]$ make all tracee@f64bb4a2f0b1[/tracee]$ sudo ./dist/tracee-ebpf \\ -o format:json \\ -o option:parse-arguments \\ --trace comm=bash \\ --trace follow \\ --trace event!='sched*' | \\ ./dist/tracee-rules \\ --input-tracee file:stdin \\ --input-tracee format:json Now, in your host's bash shell, execute: sudo strace /bin/ls and observe tracee warning you about a possible risk (with its Anti-Debugging signature). Now, for more patient readers ...","title":"Quick steps (impatient readers)"},{"location":"building/environment/#how-to-build-and-use-the-environment","text":"In order to have a controlled building environment for tracee, tracee provides a Makefile.tracee-make file that allows you to create and use docker controlled environments to build & test tracee-ebpf and tracee-rules . Two different environments are maintained for building tracee: Alpine Ubuntu The reason for that is that Alpine Linux is based in the musl C standard library, while the Ubuntu Linux uses glibc . By supporting both building environments we can always be sure that the project builds (and executes) correctly in both environments. Be aware: locally created containers, called alpine-tracee-make or ubuntu-tracee-make , share the host source code directory. This means that, if you build tracee binaries using alpine distribution, binaries tracee-ebpf and tracee-rules might not be compatible to the Linux distribution from your host OS.","title":"How to build and use the environment"},{"location":"building/environment/#creating-a-builder-environment","text":"To create an alpine-tracee-make container: $ make -f builder/Makefile.tracee-make alpine-prepare To create an ubuntu-tracee-make container: $ make -f builder/Makefile.tracee-make ubuntu-prepare","title":"Creating a builder environment"},{"location":"building/environment/#executing-a-builder-environment","text":"To execute an alpine-tracee-make shell: $ make -f builder/Makefile.tracee-make alpine-shell To execute an ubuntu-tracee-make shell: $ make -f builder/Makefile.tracee-make ubuntu-shell","title":"Executing a builder environment"},{"location":"building/environment/#using-build-environment-as-a-make-replacement","text":"Instead of executing a builder shell, you may use alpine-tracee-make , or ubuntu-tracee-make , as a replacement for the make command: $ make -f builder/Makefile.tracee-make ubuntu-prepare $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"help\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"clean\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"bpf-core\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"tracee-ebpf\" $ make -f builder/Makefile.tracee-make ubuntu-make ARG=\"all\" And, after the compilation, run the commands directly in your host: $ sudo ./dist/tracee-ebpf \\ -o option:parse-arguments \\ --trace comm=bash \\ --trace follow \\ --trace event!='sched*' Note : the generated binary must be compatible to your host (depending on glibc version, for example). If you don't want to depend on host's libraries versions, or if you are using the alpine-tracee-make container as a replacement for make , and your host is not an Alpine Linux , then you may set STATIC=1 variable so you can run compiled binaries in your host: $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-make ARG=\"help\" $ STATIC=1 make -f builder/Makefile.tracee-make alpine-make ARG=\"all\" and execute the static binary from your host: $ ldd dist/tracee-ebpf not a dynamic executable Warning : compiling tracee-rules with STATIC=1 won't allow you to use golang based signatures: 2021/12/13 13:27:21 error opening plugin /tracee/dist/rules/builtin.so: plugin.Open(\"/tracee/dist/rules/builtin.so\"): Dynamic loading not supported","title":"Using build environment as a make replacement"},{"location":"building/nocore-ebpf/","text":"Running non CO-RE Tracee \u00b6 These instructions are meant to describe how to build tracee's eBPF object for your running kernel when it does not support CO-RE . Introduction \u00b6 Tracee consists of: tracee-ebpf: Userspace agent - handles lifecycle of ebpf programs, receives events from eBPF programs eBPF code - programs loaded into the kernel for data collection tracee-rules: OPA signatures golang signatures tracee-ebpf leverages Linux's eBPF technology, which requires some kernel level integration. Tracee supports two eBPF integration modes: CO-RE: a portable mode , which will seamlessly run on all supported envs. The portable option, also known as CO-RE (compile once, run everywhere), requires that your operating system support BTF (BPF Type Format). Tracee will automatically run in CO-RE mode if it detects that the environment supports it. The tracee-ebpf binary has a CO-RE eBPF object embedded on it. When executed, it loads the CO-RE eBPF object into the kernel and each of its object's eBPF programs are executed when triggered by kernel probes, or tracepoints, for example. This mode requires no intervention or preparation on your side. You can manually detect if your environments supports it by checking if the following file exists on your machine: /sys/kernel/btf/vmlinux . non CO-RE: a kernel-specific mode , requiring eBPF object to be built. If you want to run Tracee on a host without BTF support, there are 2 options: to use BTF files from BTFhub and provide the TRACEE_BTF_FILE environment variable pointing to the BTF file of your running kernel. to have ../../Makefile build and install the eBPF object for you (instructions in this file). This will depend on having clang and a kernel version specific kernel-header package. The need for a non CO-RE eBPF object build \u00b6 Until recently , tracee-ebpf was capable of building a non CO-RE (portable) eBPF object when the running kernel did not support BTF, one of the kernel features needed for eBPF portability among different kernels. That now is changed : It is the user responsibility to have the non CO-RE eBPF object correctly placed in /tmp/tracee directory. Tracee will load it, instead of loading the embedded CO-RE eBPF object, as a last resource if there is no: BTF file available in running kernel ( /sys/kernel/btf/vmlinux ). BTF file pointed by TRACEE_BTF_FILE environment variable. BTF file embedded into \"tracee-ebpf\" binary ( BTFhub ). NOTE : Installing the non CO-RE eBPF object does not mean you will run tracee-ebpf with it by default. It only means that if your running kernel doesn't support CO-RE, it will be loaded. To force tracee-ebpf to always run non CO-RE eBPF object you have to specific TRACEE_BPF_FILE= environment variable. Reasoning behind this change With BTFhub , it is now possible to run tracee-ebpf without compiling the eBPF object to each different kernel, thus removing the automatic builds (although the functionality is still kept through the Makefile). Install the non CO-RE eBPF object \u00b6 By running: $ make clean $ make all $ make install-bpf-nocore make installs an eBPF object file under /tmp/tracee for the current running kernel. Example: $ find /tmp/tracee /tmp/tracee /tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o NOTE : In this example, the Ubuntu Focal kernel 5.4.0-91-generic supports CO-RE, but the kernel does not have embedded BTF information available. In cases like this, the user may opt to either use BTFhub btf files (with an environment variable TRACEE_BTF_FILE=.../5.4.0-91-generic.btf) OR to install the non CO-RE eBPF object and run tracee-ebpf command without an env variable. Run tracee-ebpf with the non CO-RE eBPF object \u00b6 If you install the non CO-RE eBPF object and run tracee-ebpf in an environment that needs it, then the debug output will look like: $ sudo ./dist/tracee-ebpf --debug --trace 'event!=sched*' OSInfo: ARCH: x86_64 OSInfo: VERSION: \"20.04.3 LTS (Focal Fossa)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: PRETTY_NAME: \"Ubuntu 20.04.3 LTS\" OSInfo: VERSION_ID: \"20.04\" OSInfo: VERSION_CODENAME: focal OSInfo: KERNEL_RELEASE: 5.8.0-63-generic BTF: bpfenv = false, btfenv = false, vmlinux = false BPF: no BTF file was found or provided, trying non CO-RE eBPF at /tmp/tracee/tracee.bpf.5_8_0-63-generic.v0_6_5-20-g3353501.o You can see that tracee-ebpf was picked the file from /tmp/tracee directory. One way of forcing tracee-ebpf to use non CO-RE eBPF object, even in a kernel that supports CO-RE, is by setting the TRACEE_BPF_FILE environment, like this: $ sudo TRACEE_BPF_FILE=/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o ./dist/tracee-ebpf --debug -o option:parse-arguments --trace comm=bash --trace follow --trace event!='sched*' OSInfo: PRETTY_NAME: \"Ubuntu 20.04.3 LTS\" OSInfo: VERSION_ID: \"20.04\" OSInfo: VERSION_CODENAME: focal OSInfo: KERNEL_RELEASE: 5.4.0-91-generic OSInfo: ARCH: x86_64 OSInfo: VERSION: \"20.04.3 LTS (Focal Fossa)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian BTF: bpfenv = true, btfenv = false, vmlinux = false BPF: using BPF object from environment: /tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o TIME UID COMM PID TID RET EVENT ARGS ... Use the building environment \u00b6 If you're willing to generate the non CO-RE eBPF object using the tracee-make building environment container, you're able to by doing: $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-shell or $ make -f builder/Makefile.tracee-make ubuntu-prepare $ make -f builder/Makefile.tracee-make ubuntu-shell and then, inside the docker container: tracee@f65bab137305[/tracee]$ make clean tracee@f65bab137305[/tracee]$ make tracee-ebpf tracee@f65bab137305[/tracee]$ make install-bpf-nocore tracee@f65bab137305[/tracee]$ sudo ./dist/tracee-ebpf --debug --trace 'event!=sched*' KConfig: warning: could not check enabled kconfig features (could not read /boot/config-5.8.0-63-generic: ...) KConfig: warning: assuming kconfig values, might have unexpected behavior OSInfo: KERNEL_RELEASE: 5.8.0-63-generic OSInfo: ARCH: x86_64 OSInfo: VERSION: \"21.04 (Hirsute Hippo)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: PRETTY_NAME: \"Ubuntu 21.04\" OSInfo: VERSION_ID: \"21.04\" OSInfo: VERSION_CODENAME: hirsute BTF: bpfenv = false, btfenv = false, vmlinux = false BPF: no BTF file was found or provided BPF: trying non CO-RE eBPF at /tmp/tracee/tracee.bpf.5_8_0-63-generic.v0_6_5-20-g0b921b1.o KConfig: warning: assuming kconfig values, might have unexpected behavior TIME UID COMM PID TID RET ...","title":"Building non CO-RE"},{"location":"building/nocore-ebpf/#running-non-co-re-tracee","text":"These instructions are meant to describe how to build tracee's eBPF object for your running kernel when it does not support CO-RE .","title":"Running non CO-RE Tracee"},{"location":"building/nocore-ebpf/#introduction","text":"Tracee consists of: tracee-ebpf: Userspace agent - handles lifecycle of ebpf programs, receives events from eBPF programs eBPF code - programs loaded into the kernel for data collection tracee-rules: OPA signatures golang signatures tracee-ebpf leverages Linux's eBPF technology, which requires some kernel level integration. Tracee supports two eBPF integration modes: CO-RE: a portable mode , which will seamlessly run on all supported envs. The portable option, also known as CO-RE (compile once, run everywhere), requires that your operating system support BTF (BPF Type Format). Tracee will automatically run in CO-RE mode if it detects that the environment supports it. The tracee-ebpf binary has a CO-RE eBPF object embedded on it. When executed, it loads the CO-RE eBPF object into the kernel and each of its object's eBPF programs are executed when triggered by kernel probes, or tracepoints, for example. This mode requires no intervention or preparation on your side. You can manually detect if your environments supports it by checking if the following file exists on your machine: /sys/kernel/btf/vmlinux . non CO-RE: a kernel-specific mode , requiring eBPF object to be built. If you want to run Tracee on a host without BTF support, there are 2 options: to use BTF files from BTFhub and provide the TRACEE_BTF_FILE environment variable pointing to the BTF file of your running kernel. to have ../../Makefile build and install the eBPF object for you (instructions in this file). This will depend on having clang and a kernel version specific kernel-header package.","title":"Introduction"},{"location":"building/nocore-ebpf/#the-need-for-a-non-co-re-ebpf-object-build","text":"Until recently , tracee-ebpf was capable of building a non CO-RE (portable) eBPF object when the running kernel did not support BTF, one of the kernel features needed for eBPF portability among different kernels. That now is changed : It is the user responsibility to have the non CO-RE eBPF object correctly placed in /tmp/tracee directory. Tracee will load it, instead of loading the embedded CO-RE eBPF object, as a last resource if there is no: BTF file available in running kernel ( /sys/kernel/btf/vmlinux ). BTF file pointed by TRACEE_BTF_FILE environment variable. BTF file embedded into \"tracee-ebpf\" binary ( BTFhub ). NOTE : Installing the non CO-RE eBPF object does not mean you will run tracee-ebpf with it by default. It only means that if your running kernel doesn't support CO-RE, it will be loaded. To force tracee-ebpf to always run non CO-RE eBPF object you have to specific TRACEE_BPF_FILE= environment variable. Reasoning behind this change With BTFhub , it is now possible to run tracee-ebpf without compiling the eBPF object to each different kernel, thus removing the automatic builds (although the functionality is still kept through the Makefile).","title":"The need for a non CO-RE eBPF object build"},{"location":"building/nocore-ebpf/#install-the-non-co-re-ebpf-object","text":"By running: $ make clean $ make all $ make install-bpf-nocore make installs an eBPF object file under /tmp/tracee for the current running kernel. Example: $ find /tmp/tracee /tmp/tracee /tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o NOTE : In this example, the Ubuntu Focal kernel 5.4.0-91-generic supports CO-RE, but the kernel does not have embedded BTF information available. In cases like this, the user may opt to either use BTFhub btf files (with an environment variable TRACEE_BTF_FILE=.../5.4.0-91-generic.btf) OR to install the non CO-RE eBPF object and run tracee-ebpf command without an env variable.","title":"Install the non CO-RE eBPF object"},{"location":"building/nocore-ebpf/#run-tracee-ebpf-with-the-non-co-re-ebpf-object","text":"If you install the non CO-RE eBPF object and run tracee-ebpf in an environment that needs it, then the debug output will look like: $ sudo ./dist/tracee-ebpf --debug --trace 'event!=sched*' OSInfo: ARCH: x86_64 OSInfo: VERSION: \"20.04.3 LTS (Focal Fossa)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: PRETTY_NAME: \"Ubuntu 20.04.3 LTS\" OSInfo: VERSION_ID: \"20.04\" OSInfo: VERSION_CODENAME: focal OSInfo: KERNEL_RELEASE: 5.8.0-63-generic BTF: bpfenv = false, btfenv = false, vmlinux = false BPF: no BTF file was found or provided, trying non CO-RE eBPF at /tmp/tracee/tracee.bpf.5_8_0-63-generic.v0_6_5-20-g3353501.o You can see that tracee-ebpf was picked the file from /tmp/tracee directory. One way of forcing tracee-ebpf to use non CO-RE eBPF object, even in a kernel that supports CO-RE, is by setting the TRACEE_BPF_FILE environment, like this: $ sudo TRACEE_BPF_FILE=/tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o ./dist/tracee-ebpf --debug -o option:parse-arguments --trace comm=bash --trace follow --trace event!='sched*' OSInfo: PRETTY_NAME: \"Ubuntu 20.04.3 LTS\" OSInfo: VERSION_ID: \"20.04\" OSInfo: VERSION_CODENAME: focal OSInfo: KERNEL_RELEASE: 5.4.0-91-generic OSInfo: ARCH: x86_64 OSInfo: VERSION: \"20.04.3 LTS (Focal Fossa)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian BTF: bpfenv = true, btfenv = false, vmlinux = false BPF: using BPF object from environment: /tmp/tracee/tracee.bpf.5_4_0-91-generic.v0_6_5-80-ge723a22.o TIME UID COMM PID TID RET EVENT ARGS ...","title":"Run tracee-ebpf with the non CO-RE eBPF object"},{"location":"building/nocore-ebpf/#use-the-building-environment","text":"If you're willing to generate the non CO-RE eBPF object using the tracee-make building environment container, you're able to by doing: $ make -f builder/Makefile.tracee-make alpine-prepare $ make -f builder/Makefile.tracee-make alpine-shell or $ make -f builder/Makefile.tracee-make ubuntu-prepare $ make -f builder/Makefile.tracee-make ubuntu-shell and then, inside the docker container: tracee@f65bab137305[/tracee]$ make clean tracee@f65bab137305[/tracee]$ make tracee-ebpf tracee@f65bab137305[/tracee]$ make install-bpf-nocore tracee@f65bab137305[/tracee]$ sudo ./dist/tracee-ebpf --debug --trace 'event!=sched*' KConfig: warning: could not check enabled kconfig features (could not read /boot/config-5.8.0-63-generic: ...) KConfig: warning: assuming kconfig values, might have unexpected behavior OSInfo: KERNEL_RELEASE: 5.8.0-63-generic OSInfo: ARCH: x86_64 OSInfo: VERSION: \"21.04 (Hirsute Hippo)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: PRETTY_NAME: \"Ubuntu 21.04\" OSInfo: VERSION_ID: \"21.04\" OSInfo: VERSION_CODENAME: hirsute BTF: bpfenv = false, btfenv = false, vmlinux = false BPF: no BTF file was found or provided BPF: trying non CO-RE eBPF at /tmp/tracee/tracee.bpf.5_8_0-63-generic.v0_6_5-20-g0b921b1.o KConfig: warning: assuming kconfig values, might have unexpected behavior TIME UID COMM PID TID RET ...","title":"Use the building environment"},{"location":"building/packaging/","text":"Creating Tracee Linux packages \u00b6 These instructions are meant to describe how to build Linux distributions packages If you would like to have a local building building and execution environment, read this instead. Ubuntu Fedora Ubuntu Linux \u00b6 You may use builder/Makefile.packaging to generate Ubuntu deb packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS. Building \u00b6 Bionic (LTS) $ make -f builder/Makefile.packaging ubuntu-bin-bionic Focal (LTS) $ make -f builder/Makefile.packaging ubuntu-bin-focal Impish (Current) $ make -f builder/Makefile.packaging ubuntu-bin-impish Jammy (Devel) $ make -f builder/Makefile.packaging ubuntu-bin-jammy Versioning \u00b6 The ubuntu .deb packages have the following versioning format: tracee-{ebpf,rules}_version~ubuntuver~builddate-lastcommit_arch.deb Examples: # bionic tracee-ebpf_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb tracee-rules_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb # focal tracee-ebpf_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb tracee-rules_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb # impish tracee-ebpf_0.6.5-111~21.10~2201281314-3a6874a_amd64.deb tracee-rules_0.6.5-111~21.10~2201281314-3a6874a_amd64.deb This allows upgrades among future releases of tracee AND ubuntu. It also allows you to upgrade to \"in between releases\" versions if a fix is needed. Location \u00b6 The packages will be generated in dist/ directory. Fedora Linux \u00b6 You may use builder/Makefile.packaging to generate Fedora rpm packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS. Building \u00b6 34 (still maintained) make -f builder/Makefile.packaging fedora-bin-34 35 (latest) make -f builder/Makefile.packaging fedora-bin-35 36 (devel) make -f builder/Makefile.packaging fedora-bin-36 Versioning \u00b6 The fedora .rpm packages have the following versioning format: tracee-{ebpf,rules}-version-f{34,35,36}.builddate.lastcommit.arch.rpm Examples: # f34 tracee-ebpf-0.6.5.163-f34.2202140510.ef35306d.x86_64.rpm tracee-rules-0.6.5.163-f34.2202140510.ef35306d.x86_64.rpm # f35 tracee-ebpf-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm tracee-rules-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm # f36 tracee-ebpf-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm tracee-rules-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm This allows upgrades among future releases of tracee AND fedora. It also allows you to upgrade to \"in between releases\" versions if a fix is needed. Location \u00b6 The packages will be generated in dist/ directory.","title":"OS Packaging"},{"location":"building/packaging/#creating-tracee-linux-packages","text":"These instructions are meant to describe how to build Linux distributions packages If you would like to have a local building building and execution environment, read this instead. Ubuntu Fedora","title":"Creating Tracee Linux packages"},{"location":"building/packaging/#ubuntu-linux","text":"You may use builder/Makefile.packaging to generate Ubuntu deb packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS.","title":"Ubuntu Linux"},{"location":"building/packaging/#building","text":"Bionic (LTS) $ make -f builder/Makefile.packaging ubuntu-bin-bionic Focal (LTS) $ make -f builder/Makefile.packaging ubuntu-bin-focal Impish (Current) $ make -f builder/Makefile.packaging ubuntu-bin-impish Jammy (Devel) $ make -f builder/Makefile.packaging ubuntu-bin-jammy","title":"Building"},{"location":"building/packaging/#versioning","text":"The ubuntu .deb packages have the following versioning format: tracee-{ebpf,rules}_version~ubuntuver~builddate-lastcommit_arch.deb Examples: # bionic tracee-ebpf_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb tracee-rules_0.6.5-111~18.04~2201281255-3a6874a_amd64.deb # focal tracee-ebpf_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb tracee-rules_0.6.5-111~20.04~2201281302-3a6874a_amd64.deb # impish tracee-ebpf_0.6.5-111~21.10~2201281314-3a6874a_amd64.deb tracee-rules_0.6.5-111~21.10~2201281314-3a6874a_amd64.deb This allows upgrades among future releases of tracee AND ubuntu. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.","title":"Versioning"},{"location":"building/packaging/#location","text":"The packages will be generated in dist/ directory.","title":"Location"},{"location":"building/packaging/#fedora-linux","text":"You may use builder/Makefile.packaging to generate Fedora rpm packages. It will use docker containers to generate appropriate packages, so you don't need to install build depencies in your OS.","title":"Fedora Linux"},{"location":"building/packaging/#building_1","text":"34 (still maintained) make -f builder/Makefile.packaging fedora-bin-34 35 (latest) make -f builder/Makefile.packaging fedora-bin-35 36 (devel) make -f builder/Makefile.packaging fedora-bin-36","title":"Building"},{"location":"building/packaging/#versioning_1","text":"The fedora .rpm packages have the following versioning format: tracee-{ebpf,rules}-version-f{34,35,36}.builddate.lastcommit.arch.rpm Examples: # f34 tracee-ebpf-0.6.5.163-f34.2202140510.ef35306d.x86_64.rpm tracee-rules-0.6.5.163-f34.2202140510.ef35306d.x86_64.rpm # f35 tracee-ebpf-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm tracee-rules-0.6.5.163-f35.2202140512.ef35306d.x86_64.rpm # f36 tracee-ebpf-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm tracee-rules-0.6.5.163-f36.2202140514.ef35306d.x86_64.rpm This allows upgrades among future releases of tracee AND fedora. It also allows you to upgrade to \"in between releases\" versions if a fix is needed.","title":"Versioning"},{"location":"building/packaging/#location_1","text":"The packages will be generated in dist/ directory.","title":"Location"},{"location":"install/docker-mac/","text":"Docker for Mac \u00b6 Docker for Mac does not come with Kernel headers. You need to do the following to make Tracee work: Identify your docker version: dockerver=$(docker version | grep Version | head -n 1 | cut -d ':' -f 2 | xargs) Run a container with Docker CLI, while mounting to the host path: docker run -it -v /:/host -v /var/run/docker.sock:/var/run/docker.sock docker:$dockerver /bin/sh Get the Kernel Header files from the linuxkit Docker image and copy it to the host /usr/src path: mkdir /host/kheader cd /host/kheader linux_version=\"${VERSION:-$(uname -r | cut -d - -f 1)}\" docker pull \"linuxkit/kernel:$linux_version\" docker save \"linuxkit/kernel:$linux_version\" > \"linuxkit.tar\" tar -xf \"linuxkit.tar\" layertar=$(find . -name layer.tar) tar -xf \"$layertar\" tar -xf \"kernel-dev.tar\" --directory /host/ You can now run Tracee on your Docker for Mac","title":"Docker for Mac"},{"location":"install/docker-mac/#docker-for-mac","text":"Docker for Mac does not come with Kernel headers. You need to do the following to make Tracee work: Identify your docker version: dockerver=$(docker version | grep Version | head -n 1 | cut -d ':' -f 2 | xargs) Run a container with Docker CLI, while mounting to the host path: docker run -it -v /:/host -v /var/run/docker.sock:/var/run/docker.sock docker:$dockerver /bin/sh Get the Kernel Header files from the linuxkit Docker image and copy it to the host /usr/src path: mkdir /host/kheader cd /host/kheader linux_version=\"${VERSION:-$(uname -r | cut -d - -f 1)}\" docker pull \"linuxkit/kernel:$linux_version\" docker save \"linuxkit/kernel:$linux_version\" > \"linuxkit.tar\" tar -xf \"linuxkit.tar\" layertar=$(find . -name layer.tar) tar -xf \"$layertar\" tar -xf \"kernel-dev.tar\" --directory /host/ You can now run Tracee on your Docker for Mac","title":"Docker for Mac"},{"location":"install/headers/","text":"Linux Headers \u00b6 In order to compile the kernel version specific eBPF object, Tracee needs some Linux kernel headers. Depending on your Linux distribution, there may be different ways to obtain them. Ubuntu/Debian/Arch/Manjaro: install linux-headers package. CentOS/Fedora: install kernel-headers and kernel-devel packages. macOS: follow the Docker for Mac guidelines. Normally the files will be installed in /lib/modules/${kernel_version}/build which is where Tracee expects them. If you have the headers elsewhere, you can set the KERN_HEADERS environment variable with the correct location. Note It's important that the kernel headers match the exact version of the kernel you are running. To check the current kernel version, run the command uname -r . To install a specific kernel headers version append the version to the package name: linux-headers-$(uname -r) . Warning More often than not the kernel headers files contains filesystem links to other files in other directories. Therefore, when passing the kernel headers to Tracee docker container, make sure all the necessary directories are mounted. This is why the quickstart example mounts /usr/src in addition to /lib/modules .","title":"Linux Headers"},{"location":"install/headers/#linux-headers","text":"In order to compile the kernel version specific eBPF object, Tracee needs some Linux kernel headers. Depending on your Linux distribution, there may be different ways to obtain them. Ubuntu/Debian/Arch/Manjaro: install linux-headers package. CentOS/Fedora: install kernel-headers and kernel-devel packages. macOS: follow the Docker for Mac guidelines. Normally the files will be installed in /lib/modules/${kernel_version}/build which is where Tracee expects them. If you have the headers elsewhere, you can set the KERN_HEADERS environment variable with the correct location. Note It's important that the kernel headers match the exact version of the kernel you are running. To check the current kernel version, run the command uname -r . To install a specific kernel headers version append the version to the package name: linux-headers-$(uname -r) . Warning More often than not the kernel headers files contains filesystem links to other files in other directories. Therefore, when passing the kernel headers to Tracee docker container, make sure all the necessary directories are mounted. This is why the quickstart example mounts /usr/src in addition to /lib/modules .","title":"Linux Headers"},{"location":"install/kubernetes/","text":"Deploy on Kubernetes \u00b6 In the deploy/kubernetes directory you can find Yaml files to deploy Tracee in a Kubernetes environment. This will deploy Tracee as a DaemonSet, alongside a message routing application that will help you consume the detections in your preferred way (e.g. slack, email, JIRA and more). Install Tracee \u00b6 With Postee \u00b6 To install Tracee with Postee , simply run: kubectl create \\ -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml \\ -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.7.0/deploy/kubernetes/tracee-postee/tracee.yaml You can edit the configMap postee-config the was created, see an example configuration here: https://github.com/aquasecurity/postee/blob/main/cfg.yaml. You can also use the Postee UI to configure integrations. With Falcosidekick \u00b6 To install Tracee with Falcosidekick , simply run: kubectl create \\ -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.7.0/deploy/kubernetes/tracee-falcosidekick/falcosidekick.yaml \\ -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.7.0/deploy/kubernetes/tracee-falcosidekick/tracee.yaml You can edit the configMap falcosidekick-config the was created, see an example configuration here: https://github.com/falcosecurity/falcosidekick/blob/master/config_example.yaml Platform Support \u00b6 This approach assumes that host nodes have either BTF available or kernel headers available under conventional location. See Tracee's prerequisites for more info. For the major Kubernetes platforms this should work out-of-the-box, including GKE, EKS, AKS, minikube.","title":"Kubernetes"},{"location":"install/kubernetes/#deploy-on-kubernetes","text":"In the deploy/kubernetes directory you can find Yaml files to deploy Tracee in a Kubernetes environment. This will deploy Tracee as a DaemonSet, alongside a message routing application that will help you consume the detections in your preferred way (e.g. slack, email, JIRA and more).","title":"Deploy on Kubernetes"},{"location":"install/kubernetes/#install-tracee","text":"","title":"Install Tracee"},{"location":"install/kubernetes/#with-postee","text":"To install Tracee with Postee , simply run: kubectl create \\ -f https://raw.githubusercontent.com/aquasecurity/postee/main/deploy/kubernetes/postee.yaml \\ -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.7.0/deploy/kubernetes/tracee-postee/tracee.yaml You can edit the configMap postee-config the was created, see an example configuration here: https://github.com/aquasecurity/postee/blob/main/cfg.yaml. You can also use the Postee UI to configure integrations.","title":"With Postee"},{"location":"install/kubernetes/#with-falcosidekick","text":"To install Tracee with Falcosidekick , simply run: kubectl create \\ -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.7.0/deploy/kubernetes/tracee-falcosidekick/falcosidekick.yaml \\ -f https://raw.githubusercontent.com/aquasecurity/tracee/v0.7.0/deploy/kubernetes/tracee-falcosidekick/tracee.yaml You can edit the configMap falcosidekick-config the was created, see an example configuration here: https://github.com/falcosecurity/falcosidekick/blob/master/config_example.yaml","title":"With Falcosidekick"},{"location":"install/kubernetes/#platform-support","text":"This approach assumes that host nodes have either BTF available or kernel headers available under conventional location. See Tracee's prerequisites for more info. For the major Kubernetes platforms this should work out-of-the-box, including GKE, EKS, AKS, minikube.","title":"Platform Support"},{"location":"install/prerequisites/","text":"Prerequisites \u00b6 A longterm supported kernel ( kernel.org ): 4.19, 5.4, 5.10, 5.15, 5.16 (stable) most distributions longterm supported kernels are supported as well, including CentOS8 4.18 kernel. For tracee:latest docker image, you should have one of the two: A kernel that has /sys/kernel/btf/vmlinux file available A kernel supported through BTFHUB see libbpf CO-RE documentation for more info For tracee:full docker image: Kernel Headers package clang 12 or 13 golang 1.17 libelf and libelf-dev (or elfutils-libelf and elfutils-libelf-devel) zlib1g and lib1g-dev (or zlib and zlib-devel) Permissions \u00b6 For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities: Manage eBPF maps limits ( CAP_SYS_RESOURCE ) Load and Attach eBPF programs: CAP_BPF + CAP_PERFMON for recent kernels (>=5.8) or CAP_SYS_ADMIN for older kernels On some environments (e.g. Ubuntu) CAP_IPC_LOCK might be required as well. Alternatively, run as root or with the --privileged flag of Docker.","title":"Prerequisites"},{"location":"install/prerequisites/#prerequisites","text":"A longterm supported kernel ( kernel.org ): 4.19, 5.4, 5.10, 5.15, 5.16 (stable) most distributions longterm supported kernels are supported as well, including CentOS8 4.18 kernel. For tracee:latest docker image, you should have one of the two: A kernel that has /sys/kernel/btf/vmlinux file available A kernel supported through BTFHUB see libbpf CO-RE documentation for more info For tracee:full docker image: Kernel Headers package clang 12 or 13 golang 1.17 libelf and libelf-dev (or elfutils-libelf and elfutils-libelf-devel) zlib1g and lib1g-dev (or zlib and zlib-devel)","title":"Prerequisites"},{"location":"install/prerequisites/#permissions","text":"For using the eBPF Linux subsystem, Tracee needs to run with sufficient capabilities: Manage eBPF maps limits ( CAP_SYS_RESOURCE ) Load and Attach eBPF programs: CAP_BPF + CAP_PERFMON for recent kernels (>=5.8) or CAP_SYS_ADMIN for older kernels On some environments (e.g. Ubuntu) CAP_IPC_LOCK might be required as well. Alternatively, run as root or with the --privileged flag of Docker.","title":"Permissions"},{"location":"tracee-ebpf/","text":"Tracing \u00b6 In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case you can use Tracee's eBPF collector component, which will start dumping raw data directly into standard output. Watch a quick video demo of Tracee's eBPF tracing capabilities Quickstart \u00b6 Before you proceed, make sure you follow the minimum requirements for running Tracee . docker run \\ --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ -e TRACEE_EBPF_ONLY = 1 \\ aquasec/tracee:0.7.0 Here we are running the same aquasec/tracee container, but with the TRACEE_EBPF_ONLY=1 environment variable set, which will start just a raw trace (Tracee-eBPF), without the detection engine (Tracee-Rules). Here's a sample output of running with no additional arguments: TIME(s) UID COMM PID TID RET EVENT ARGS 176751.746515 1000 zsh 14726 14726 0 execve pathname: /usr/bin/ls, argv: [ls] 176751.746772 1000 zsh 14726 14726 0 security_bprm_check pathname: /usr/bin/ls, dev: 8388610, inode: 777 176751.747044 1000 ls 14726 14726 -2 access pathname: /etc/ld.so.preload, mode: R_OK 176751.747077 1000 ls 14726 14726 0 security_file_open pathname: /etc/ld.so.cache, flags: O_RDONLY|O_LARGEFILE, dev: 8388610, inode: 533737 ... Each line is a single event collected by Tracee-eBPF, with the following information: TIME - shows the event time relative to system boot time in seconds UID - real user id (in host user namespace) of the calling process COMM - name of the calling process PID - pid of the calling process TID - tid of the calling thread RET - value returned by the function EVENT - identifies the event (e.g. syscall name) ARGS - list of arguments given to the function Getting Tracee-eBPF \u00b6 You can use Tracee-eBPF in any of the following ways: Use the docker image from Docker Hub: aquasec/tracee:0.7.0 with the trace sub-command. Download from the GitHub Releases ( tracee.tar.gz ). Build the executable from source using make . Have a building container and then build tracee with it: make -f builder/Makefile.tracee-make help Build the container images: make -f builder/Makefile.tracee-container help Build OS packages: make -f builder/Makefile.packaging help All of the other setup options and considerations listed under Tracee's Installation section applies to Tracee-eBPF as well.","title":"Getting Started"},{"location":"tracee-ebpf/#tracing","text":"In some cases, you might want to leverage Tracee's eBPF event collection capabilities directly, without involving the detection engine. This might be useful for debugging/troubleshooting/analysis/research/education. In this case you can use Tracee's eBPF collector component, which will start dumping raw data directly into standard output. Watch a quick video demo of Tracee's eBPF tracing capabilities","title":"Tracing"},{"location":"tracee-ebpf/#quickstart","text":"Before you proceed, make sure you follow the minimum requirements for running Tracee . docker run \\ --name tracee --rm -it \\ --pid = host --cgroupns = host --privileged \\ -v /etc/os-release:/etc/os-release-host:ro \\ -e LIBBPFGO_OSRELEASE_FILE = /etc/os-release-host \\ -e TRACEE_EBPF_ONLY = 1 \\ aquasec/tracee:0.7.0 Here we are running the same aquasec/tracee container, but with the TRACEE_EBPF_ONLY=1 environment variable set, which will start just a raw trace (Tracee-eBPF), without the detection engine (Tracee-Rules). Here's a sample output of running with no additional arguments: TIME(s) UID COMM PID TID RET EVENT ARGS 176751.746515 1000 zsh 14726 14726 0 execve pathname: /usr/bin/ls, argv: [ls] 176751.746772 1000 zsh 14726 14726 0 security_bprm_check pathname: /usr/bin/ls, dev: 8388610, inode: 777 176751.747044 1000 ls 14726 14726 -2 access pathname: /etc/ld.so.preload, mode: R_OK 176751.747077 1000 ls 14726 14726 0 security_file_open pathname: /etc/ld.so.cache, flags: O_RDONLY|O_LARGEFILE, dev: 8388610, inode: 533737 ... Each line is a single event collected by Tracee-eBPF, with the following information: TIME - shows the event time relative to system boot time in seconds UID - real user id (in host user namespace) of the calling process COMM - name of the calling process PID - pid of the calling process TID - tid of the calling thread RET - value returned by the function EVENT - identifies the event (e.g. syscall name) ARGS - list of arguments given to the function","title":"Quickstart"},{"location":"tracee-ebpf/#getting-tracee-ebpf","text":"You can use Tracee-eBPF in any of the following ways: Use the docker image from Docker Hub: aquasec/tracee:0.7.0 with the trace sub-command. Download from the GitHub Releases ( tracee.tar.gz ). Build the executable from source using make . Have a building container and then build tracee with it: make -f builder/Makefile.tracee-make help Build the container images: make -f builder/Makefile.tracee-container help Build OS packages: make -f builder/Makefile.packaging help All of the other setup options and considerations listed under Tracee's Installation section applies to Tracee-eBPF as well.","title":"Getting Tracee-eBPF"},{"location":"tracee-ebpf/capture/","text":"Capturing Artifacts \u00b6 Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the --capture flag. All captured artifacts are saved in Tracee's \"output directory\" which can be configured using --capture dir:/path/to/dir . Tracee can capture the following types of artifacts: Written files: Anytime a file is being written to, the contents of the file will be captured. Written files can be filtered using an optional path prefix. Executed files: Anytime a binary is being executed, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once. Memory files: Anytime a \"memory unpacker\" is detected, the suspicious memory region will be captured. This is triggered when memory protection changes from Write+Execute to Write. Network pcap files: Anytime a packet goes through the network interface, the packet is captured into the pcap file. only packets that are generated by traced processes are being captured. Loaded kernel modules: Anytime a kernel module is being loaded, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once. CLI Options \u00b6 CLI Option Description [artifact:]write[=/path/prefix*] capture written files. A filter can be given to only capture file writes whose path starts with some prefix (up to 50 characters). Up to 3 filters can be given. [artifact:]exec capture executed files. [artifact:]mem capture memory regions that had write+execute (w+x) protection, and then changed to execute (x) only. [artifact:]net=<network_interface> capture network packets generated by traced processes, that goes through . Only TCP/UDP protocols are currently supported. profile creates a runtime profile of program executions and their metadata for forensics use. dir:/path/to/dir path where tracee will save produced artifacts. the artifact will be saved into an 'out' subdirectory. (default: /tmp/tracee). clear-dir clear the captured artifacts output dir before starting (default: false). pcap:per-container when capturing network packets, save pcap per container pcap:per-process when capturing network packets, save pcap per process (Use this flag multiple times to choose multiple capture options) Examples \u00b6 Capture executed files into the default output directory --capture exec Capture kernel modules into the default output directory --capture module Delete /my/dir/out and then capture executed files into it --capture exec --capture dir:/my/dir --capture clear-dir Capture files that were written into anywhere under /usr/bin/ or /etc/ --capture write=/usr/bin/* --capture write=/etc/* Capture pcap files --capture net=enp0s3 --capture net=enp0s3 --capture pcap:per-container Creates a runtime profile of program executions and their metadata for forensics use. The profiles created can be compared among executions to identify if there is any difference. For example, use it as a github action to identify if any new process was executed since the last pipeline , useful for supply chain security. --capture profile","title":"Capturing Artifacts"},{"location":"tracee-ebpf/capture/#capturing-artifacts","text":"Tracee has a unique feature that lets you capture interesting artifacts from running applications, using the --capture flag. All captured artifacts are saved in Tracee's \"output directory\" which can be configured using --capture dir:/path/to/dir . Tracee can capture the following types of artifacts: Written files: Anytime a file is being written to, the contents of the file will be captured. Written files can be filtered using an optional path prefix. Executed files: Anytime a binary is being executed, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once. Memory files: Anytime a \"memory unpacker\" is detected, the suspicious memory region will be captured. This is triggered when memory protection changes from Write+Execute to Write. Network pcap files: Anytime a packet goes through the network interface, the packet is captured into the pcap file. only packets that are generated by traced processes are being captured. Loaded kernel modules: Anytime a kernel module is being loaded, the binary file will be captured. If the same binary is executed multiple times, it will be captured just once.","title":"Capturing Artifacts"},{"location":"tracee-ebpf/capture/#cli-options","text":"CLI Option Description [artifact:]write[=/path/prefix*] capture written files. A filter can be given to only capture file writes whose path starts with some prefix (up to 50 characters). Up to 3 filters can be given. [artifact:]exec capture executed files. [artifact:]mem capture memory regions that had write+execute (w+x) protection, and then changed to execute (x) only. [artifact:]net=<network_interface> capture network packets generated by traced processes, that goes through . Only TCP/UDP protocols are currently supported. profile creates a runtime profile of program executions and their metadata for forensics use. dir:/path/to/dir path where tracee will save produced artifacts. the artifact will be saved into an 'out' subdirectory. (default: /tmp/tracee). clear-dir clear the captured artifacts output dir before starting (default: false). pcap:per-container when capturing network packets, save pcap per container pcap:per-process when capturing network packets, save pcap per process (Use this flag multiple times to choose multiple capture options)","title":"CLI Options"},{"location":"tracee-ebpf/capture/#examples","text":"Capture executed files into the default output directory --capture exec Capture kernel modules into the default output directory --capture module Delete /my/dir/out and then capture executed files into it --capture exec --capture dir:/my/dir --capture clear-dir Capture files that were written into anywhere under /usr/bin/ or /etc/ --capture write=/usr/bin/* --capture write=/etc/* Capture pcap files --capture net=enp0s3 --capture net=enp0s3 --capture pcap:per-container Creates a runtime profile of program executions and their metadata for forensics use. The profiles created can be compared among executions to identify if there is any difference. For example, use it as a github action to identify if any new process was executed since the last pipeline , useful for supply chain security. --capture profile","title":"Examples"},{"location":"tracee-ebpf/output/","text":"Output Options \u00b6 Control how and where output is printed. CLI Options \u00b6 CLI Option Description [format:]{table,table-verbose,json,gob,gotemplate=/path/to/template} output events in the specified format. for gotemplate, specify the mandatory template file none ignore stream of events output, usually used with --capture out-file:/path/to/file write the output to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stdout) err-file:/path/to/file write the errors to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stderr) option:{stack-addresses,detect-syscall,exec-env,exec-hash,relative-time,parse-arguments} augment output according to given options (default: none) stack-addresses include stack memory addresses for each event detect-syscall when tracing kernel functions which are not syscalls, detect and show the original syscall that called that function exec-env when tracing execve/execveat, show the environment variables that were used for execution exec-hash when tracing sched_process_exec, show the file hash(sha256) relative-time use relative timestamp instead of wall timestamp for events parse-arguments do not show raw machine-readable values for event arguments, instead parse into human readable strings (Use this flag multiple times to choose multiple capture options) Examples \u00b6 output as json --output json output as the provided go template --output gotemplate=/path/to/my.tmpl output to /my/out and errors to /my/err --output out-file:/my/out --output err-file:/my/err","title":"Output Options"},{"location":"tracee-ebpf/output/#output-options","text":"Control how and where output is printed.","title":"Output Options"},{"location":"tracee-ebpf/output/#cli-options","text":"CLI Option Description [format:]{table,table-verbose,json,gob,gotemplate=/path/to/template} output events in the specified format. for gotemplate, specify the mandatory template file none ignore stream of events output, usually used with --capture out-file:/path/to/file write the output to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stdout) err-file:/path/to/file write the errors to a specified file. the path to the file will be created if not existing and the file will be deleted if existing (default: stderr) option:{stack-addresses,detect-syscall,exec-env,exec-hash,relative-time,parse-arguments} augment output according to given options (default: none) stack-addresses include stack memory addresses for each event detect-syscall when tracing kernel functions which are not syscalls, detect and show the original syscall that called that function exec-env when tracing execve/execveat, show the environment variables that were used for execution exec-hash when tracing sched_process_exec, show the file hash(sha256) relative-time use relative timestamp instead of wall timestamp for events parse-arguments do not show raw machine-readable values for event arguments, instead parse into human readable strings (Use this flag multiple times to choose multiple capture options)","title":"CLI Options"},{"location":"tracee-ebpf/output/#examples","text":"output as json --output json output as the provided go template --output gotemplate=/path/to/my.tmpl output to /my/out and errors to /my/err --output out-file:/my/out --output err-file:/my/err","title":"Examples"},{"location":"tracee-ebpf/override-os-needed-files/","text":"Overriding OS needed files \u00b6 Tracee supports eBPF CO-RE (Compile Once - Run Everywhere) technology and, because of that, it might need some information about the Linux OS it is running at. Tracee, through libbpfgo, must have access to /etc/os-release file AND either /boot/config-$(uname-r) OR /proc/config.gz files (KernelConfig API at helpers/kernel_config). Note that, despite having this need, tracee will try to execute as CO-RE eBPF program in any environment it is executed. /etc/os-release \u00b6 Tracee will show you collected information about the running Linux OS with the --debug argument: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: VERSION_ID: \"21.04\" OSInfo: VERSION_CODENAME: hirsute OSInfo: KERNEL_RELEASE: 5.11.0-31-generic OSInfo: VERSION: \"21.04 (Hirsute Hippo)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: PRETTY_NAME: \"Ubuntu 21.04\" BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 02:34:43:212623 1000 bash 2787679 2787679 0 execve pathname: /bin/true, argv: [/bin/true] If, because you're running in a distribution that does not have /etc/os-release, or because you're running inside a container that does not support it, you may face: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: warning: os-release file could not be found (open /etc/os-release: no such file or directory) BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:37:02:831787 1000 bash 13940 13940 0 execve pathname: /bin/true, argv: [/bin/true] End of events stream Stats: {EventCount:1 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0} But do note that tracee-ebpf shall continue working (informing only the KERNEL_RELEASE OSInfo option). If you need to override the underlaying Linux OS information, because you're running inside a container that already has /etc/os-release file, for example, you may create another os-release file and inform tracee-ebpf by using LIBBPFGO's environment variable LIBBPFGO_OSRELEASE_FILE : $ sudo LIBBPFGO_OSRELEASE_FILE=/etc/os-release.orig ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:39:24:100006 1000 bash 14014 14014 0 execve pathname: /bin/true, argv: [/bin/true] If you're running tracee inside a docker container, you can simply bind mount /etc/os-release from the host as /etc/os-release-host into the guest and inform that through the LIBBPFGO_OSRELEASE_FILE environment variable. /proc/config.gz OR /boot/config-$(uname -r) \u00b6 Tracee needs access to kconfig file in order to: Check if the kernel of your running environment supports needed eBPF features Provide kconfig variables to its eBPF counter-part (so eBPF program take decisions) Tracee should NOT fail when it cannot find a kconfig file: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve KConfig: warning: could not check enabled kconfig features (could not read /boot/config-5.14.0-rc5+: stat /boot/config-5.14.0-rc5+: no such file or directory) OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:44:18:877838 1000 bash 14089 14089 0 execve pathname: /bin/true, argv: [/bin/true] but do have in mind it is assuming some things from the host environment and its behavior might have inconsistencies. If you are running tracee in an environment that does not have a kconfig file (nor /proc/config.gz support), it is recommended that you provide the host kconfig file location to tracee through the LIBBPFGO_KCONFIG_FILE environment variable: $ sudo LIBBPFGO_KCONFIG_FILE=/boot/config-5.14.0-rc5+.orig ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:47:45:245869 1000 bash 14165 14165 0 execve pathname: /bin/true, argv: [/bin/true] If you're running tracee inside a docker container, you can simply bind mount /boot/config-$(uname -r) from the host as /boot/config-$(uname -r) into the guest and inform that through the LIBBPFGO_OSRELEASE_FILE environment variable. ATTENTION: in case kconfig file is NOT found \u00b6 In case no kconfig file is found, tracee takes some decisions blindly and it may give you unexpected errors. Example: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve KConfig: warning: could not check enabled kconfig features (could not read /boot/config-5.14.0-rc5+: stat /boot/config-5.14.0-rc5+: no such file or directory) OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:50:53:742705 1000 bash 14244 14244 0 execve pathname: , argv: [] In this example tracee has assumed the environment had CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y kconfig option set but that wasn't the case. It led tracee not to be able to get syscalls arguments correctly.","title":"Overriding OS needed files"},{"location":"tracee-ebpf/override-os-needed-files/#overriding-os-needed-files","text":"Tracee supports eBPF CO-RE (Compile Once - Run Everywhere) technology and, because of that, it might need some information about the Linux OS it is running at. Tracee, through libbpfgo, must have access to /etc/os-release file AND either /boot/config-$(uname-r) OR /proc/config.gz files (KernelConfig API at helpers/kernel_config). Note that, despite having this need, tracee will try to execute as CO-RE eBPF program in any environment it is executed.","title":"Overriding OS needed files"},{"location":"tracee-ebpf/override-os-needed-files/#etcos-release","text":"Tracee will show you collected information about the running Linux OS with the --debug argument: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: VERSION_ID: \"21.04\" OSInfo: VERSION_CODENAME: hirsute OSInfo: KERNEL_RELEASE: 5.11.0-31-generic OSInfo: VERSION: \"21.04 (Hirsute Hippo)\" OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: PRETTY_NAME: \"Ubuntu 21.04\" BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 02:34:43:212623 1000 bash 2787679 2787679 0 execve pathname: /bin/true, argv: [/bin/true] If, because you're running in a distribution that does not have /etc/os-release, or because you're running inside a container that does not support it, you may face: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: warning: os-release file could not be found (open /etc/os-release: no such file or directory) BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:37:02:831787 1000 bash 13940 13940 0 execve pathname: /bin/true, argv: [/bin/true] End of events stream Stats: {EventCount:1 ErrorCount:0 LostEvCount:0 LostWrCount:0 LostNtCount:0} But do note that tracee-ebpf shall continue working (informing only the KERNEL_RELEASE OSInfo option). If you need to override the underlaying Linux OS information, because you're running inside a container that already has /etc/os-release file, for example, you may create another os-release file and inform tracee-ebpf by using LIBBPFGO's environment variable LIBBPFGO_OSRELEASE_FILE : $ sudo LIBBPFGO_OSRELEASE_FILE=/etc/os-release.orig ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:39:24:100006 1000 bash 14014 14014 0 execve pathname: /bin/true, argv: [/bin/true] If you're running tracee inside a docker container, you can simply bind mount /etc/os-release from the host as /etc/os-release-host into the guest and inform that through the LIBBPFGO_OSRELEASE_FILE environment variable.","title":"/etc/os-release"},{"location":"tracee-ebpf/override-os-needed-files/#procconfiggz-or-bootconfig-uname-r","text":"Tracee needs access to kconfig file in order to: Check if the kernel of your running environment supports needed eBPF features Provide kconfig variables to its eBPF counter-part (so eBPF program take decisions) Tracee should NOT fail when it cannot find a kconfig file: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve KConfig: warning: could not check enabled kconfig features (could not read /boot/config-5.14.0-rc5+: stat /boot/config-5.14.0-rc5+: no such file or directory) OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:44:18:877838 1000 bash 14089 14089 0 execve pathname: /bin/true, argv: [/bin/true] but do have in mind it is assuming some things from the host environment and its behavior might have inconsistencies. If you are running tracee in an environment that does not have a kconfig file (nor /proc/config.gz support), it is recommended that you provide the host kconfig file location to tracee through the LIBBPFGO_KCONFIG_FILE environment variable: $ sudo LIBBPFGO_KCONFIG_FILE=/boot/config-5.14.0-rc5+.orig ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:47:45:245869 1000 bash 14165 14165 0 execve pathname: /bin/true, argv: [/bin/true] If you're running tracee inside a docker container, you can simply bind mount /boot/config-$(uname -r) from the host as /boot/config-$(uname -r) into the guest and inform that through the LIBBPFGO_OSRELEASE_FILE environment variable.","title":"/proc/config.gz OR /boot/config-$(uname -r)"},{"location":"tracee-ebpf/override-os-needed-files/#attention-in-case-kconfig-file-is-not-found","text":"In case no kconfig file is found, tracee takes some decisions blindly and it may give you unexpected errors. Example: $ sudo ./dist/tracee-ebpf --debug --trace uid=1000 --trace pid=new --trace event=execve KConfig: warning: could not check enabled kconfig features (could not read /boot/config-5.14.0-rc5+: stat /boot/config-5.14.0-rc5+: no such file or directory) OSInfo: PRETTY_NAME: \"Ubuntu Impish Indri (development branch)\" OSInfo: VERSION_ID: \"21.10\" OSInfo: VERSION: \"21.10 (Impish Indri)\" OSInfo: VERSION_CODENAME: impish OSInfo: ID: ubuntu OSInfo: ID_LIKE: debian OSInfo: KERNEL_RELEASE: 5.14.0-rc5+ BTF: bpfenv = false, btfenv = false, vmlinux = true BPF: using embedded BPF object unpacked CO:RE bpf object file into memory TIME UID COMM PID TID RET EVENT ARGS 05:50:53:742705 1000 bash 14244 14244 0 execve pathname: , argv: [] In this example tracee has assumed the environment had CONFIG_ARCH_HAS_SYSCALL_WRAPPER=y kconfig option set but that wasn't the case. It led tracee not to be able to get syscalls arguments correctly.","title":"ATTENTION: in case kconfig file is NOT found"},{"location":"tracee-ebpf/trace-options/","text":"Trace Options \u00b6 Trace output can easily become unwieldy when tracing all of the events from all of the system. Luckily, Tracee has a powerful mechanism to accurately trace just the information that is relevant to you, using the --trace flag. Using the --trace you define expressions that tells Tracee-eBPF what you are interested in by means of event metadata, and process metadata. Only events that match this criteria will be traced. You can filter by most of the visible fields on a Tracee event. For example to trace only events related to user ID 1000, use --trace uid=1000 . You can combine trace expressions into more complex criteria. For example, to trace only events related to user ID 1000, which come from process ID 1234, use --trace uid=1000 --trace pid=1234 . A special pid value is new which let's you trace all newly created processes (that were created after Tracee started tracing). Tracee-eBPF lets you easily trace events that originate in containers using --trace container or only new containers (that were created after Tracee started) using --trace container=new . Event metadata can be used in trace expression as well. For example, to trace only openat syscalls, use --trace event:openat . But you can also filter on a specific argument of the event, e.g --trace openat.pathname=/bin/ls which will show only openat syscalls that operate on the file /bin/ls . A useful trace mode is the --trace follow which, if specified, will trace not only processes that match the given trace expressions, but also their child processes. For example, the following will trace all the events that originate from zsh shell, including all of the processes that it will spawn: --trace comm=zsh --trace follow . CLI Options \u00b6 Only events that match all trace expressions will be traced (trace flags are ANDed). The following types of expressions are supported: Numerical expressions which compare numbers and allow the following operators: '=', '!=', '<', '>'. Available numerical expressions: uid, pid, mntns, pidns. String expressions which compares text and allow the following operators: '=', '!='. Available string expressions: event, set, uts, comm, container. Boolean expressions that check if a boolean is true and allow the following operator: '!'. Available boolean expressions: container. Event arguments can be accessed using 'event_name.event_arg' and provide a way to filter an event by its arguments. Event arguments allow the following operators: '=', '!='. Strings can be compared as a prefix if ending with '*'. Event return value can be accessed using 'event_name.retval' and provide a way to filter an event by its return value. Event return value expression has the same syntax as a numerical expression. Non-boolean expressions can compare a field to multiple values separated by ','. Multiple values are ORed if used with equals operator '=', but are ANDed if used with any other operator. The field 'container' and 'pid' also support the special value 'new' which selects new containers or pids, respectively. The field 'set' selects a set of events to trace according to predefined sets, which can be listed by using the 'list' flag. The special 'follow' expression declares that not only processes that match the criteria will be traced, but also their descendants. Note: some of the above operators have special meanings in different shells. To 'escape' those operators, please use single quotes, e.g.: 'uid>0' Examples \u00b6 only trace events from new processes --trace pid=new only trace events from pid 510 or pid 1709 --trace pid=510,1709 only trace events from pid 510 or pid 1709 (same as above) --trace p=510 --trace p=1709 only trace events from newly created containers --trace container=new only trace events from container id ab356bc4dd554 --trace container=ab356bc4dd554 only trace events from containers --trace container only trace events from containers (same as above) --trace c only trace events from the host --trace '!container' only trace events from uid 0 --trace uid=0 only trace events from mntns id 4026531840 --trace mntns=4026531840 only trace events from pidns id not equal to 4026531840 --trace pidns!=4026531836 only trace events from uids greater than 0 --trace 'uid>0' only trace events from pids between 0 and 1000 --trace 'pid>0' --trace 'pid<1000' only trace events from uids greater than 0 but not 1000 --trace 'u>0' --trace u!=1000 only trace execve and open events --trace event=execve,open only trace events prefixed by \"open\" --trace event=open* don't trace events prefixed by \"open\" or \"dup\" --trace event!=open*,dup* trace all file-system related events --trace set=fs trace all file-system related events, but not open(at) --trace s=fs --trace e!=open,openat don't trace events from uts name ab356bc4dd554 --trace uts!=ab356bc4dd554 only trace events from ls command --trace comm=ls only trace 'close' events that have 'fd' equals 5 --trace close.fd=5 only trace 'openat' events that have 'pathname' prefixed by \"/tmp\" --trace openat.pathname=/tmp* don't trace 'openat' events that have 'pathname' equals /tmp/1 or /bin/ls --trace openat.pathname!=/tmp/1,/bin/ls trace all events that originated from bash or from one of the processes spawned by bash --trace comm=bash --trace follow","title":"Trace Options"},{"location":"tracee-ebpf/trace-options/#trace-options","text":"Trace output can easily become unwieldy when tracing all of the events from all of the system. Luckily, Tracee has a powerful mechanism to accurately trace just the information that is relevant to you, using the --trace flag. Using the --trace you define expressions that tells Tracee-eBPF what you are interested in by means of event metadata, and process metadata. Only events that match this criteria will be traced. You can filter by most of the visible fields on a Tracee event. For example to trace only events related to user ID 1000, use --trace uid=1000 . You can combine trace expressions into more complex criteria. For example, to trace only events related to user ID 1000, which come from process ID 1234, use --trace uid=1000 --trace pid=1234 . A special pid value is new which let's you trace all newly created processes (that were created after Tracee started tracing). Tracee-eBPF lets you easily trace events that originate in containers using --trace container or only new containers (that were created after Tracee started) using --trace container=new . Event metadata can be used in trace expression as well. For example, to trace only openat syscalls, use --trace event:openat . But you can also filter on a specific argument of the event, e.g --trace openat.pathname=/bin/ls which will show only openat syscalls that operate on the file /bin/ls . A useful trace mode is the --trace follow which, if specified, will trace not only processes that match the given trace expressions, but also their child processes. For example, the following will trace all the events that originate from zsh shell, including all of the processes that it will spawn: --trace comm=zsh --trace follow .","title":"Trace Options"},{"location":"tracee-ebpf/trace-options/#cli-options","text":"Only events that match all trace expressions will be traced (trace flags are ANDed). The following types of expressions are supported: Numerical expressions which compare numbers and allow the following operators: '=', '!=', '<', '>'. Available numerical expressions: uid, pid, mntns, pidns. String expressions which compares text and allow the following operators: '=', '!='. Available string expressions: event, set, uts, comm, container. Boolean expressions that check if a boolean is true and allow the following operator: '!'. Available boolean expressions: container. Event arguments can be accessed using 'event_name.event_arg' and provide a way to filter an event by its arguments. Event arguments allow the following operators: '=', '!='. Strings can be compared as a prefix if ending with '*'. Event return value can be accessed using 'event_name.retval' and provide a way to filter an event by its return value. Event return value expression has the same syntax as a numerical expression. Non-boolean expressions can compare a field to multiple values separated by ','. Multiple values are ORed if used with equals operator '=', but are ANDed if used with any other operator. The field 'container' and 'pid' also support the special value 'new' which selects new containers or pids, respectively. The field 'set' selects a set of events to trace according to predefined sets, which can be listed by using the 'list' flag. The special 'follow' expression declares that not only processes that match the criteria will be traced, but also their descendants. Note: some of the above operators have special meanings in different shells. To 'escape' those operators, please use single quotes, e.g.: 'uid>0'","title":"CLI Options"},{"location":"tracee-ebpf/trace-options/#examples","text":"only trace events from new processes --trace pid=new only trace events from pid 510 or pid 1709 --trace pid=510,1709 only trace events from pid 510 or pid 1709 (same as above) --trace p=510 --trace p=1709 only trace events from newly created containers --trace container=new only trace events from container id ab356bc4dd554 --trace container=ab356bc4dd554 only trace events from containers --trace container only trace events from containers (same as above) --trace c only trace events from the host --trace '!container' only trace events from uid 0 --trace uid=0 only trace events from mntns id 4026531840 --trace mntns=4026531840 only trace events from pidns id not equal to 4026531840 --trace pidns!=4026531836 only trace events from uids greater than 0 --trace 'uid>0' only trace events from pids between 0 and 1000 --trace 'pid>0' --trace 'pid<1000' only trace events from uids greater than 0 but not 1000 --trace 'u>0' --trace u!=1000 only trace execve and open events --trace event=execve,open only trace events prefixed by \"open\" --trace event=open* don't trace events prefixed by \"open\" or \"dup\" --trace event!=open*,dup* trace all file-system related events --trace set=fs trace all file-system related events, but not open(at) --trace s=fs --trace e!=open,openat don't trace events from uts name ab356bc4dd554 --trace uts!=ab356bc4dd554 only trace events from ls command --trace comm=ls only trace 'close' events that have 'fd' equals 5 --trace close.fd=5 only trace 'openat' events that have 'pathname' prefixed by \"/tmp\" --trace openat.pathname=/tmp* don't trace 'openat' events that have 'pathname' equals /tmp/1 or /bin/ls --trace openat.pathname!=/tmp/1,/bin/ls trace all events that originated from bash or from one of the processes spawned by bash --trace comm=bash --trace follow","title":"Examples"}]}